// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICycleCollectorListener.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// nsICycleCollectorHandler is the interface JS code should implement to
    /// receive the results logged by a @mozilla.org/cycle-collector-logger;1
    /// instance. Pass an instance of this to the logger's 'processNext' method
    /// after the collection has run. This will describe the objects the cycle
    /// collector visited, the edges it found, and the conclusions it reached
    /// about the liveness of objects.
    ///
    /// In more detail:
    /// - For each node in the graph:
    /// - a call is made to either |noteRefCountedObject| or |noteGCedObject|, to
    /// describe the node itself; and
    /// - for each edge starting at that node, a call is made to |noteEdge|.
    ///
    /// - Then, a series of calls are made to:
    /// - |describeRoot|, for reference-counted nodes that the CC has identified as
    /// being alive because there are unknown references to those nodes.
    /// - |describeGarbage|, for nodes the cycle collector has identified as garbage.
    ///
    /// Any node not mentioned in a call to |describeRoot| or |describeGarbage| is
    /// neither a root nor garbage. The cycle collector was able to find all of the
    /// edges implied by the node's reference count.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("7f093367-1492-4b89-87af-c01dbc831246")]
	public interface nsICycleCollectorHandler
	{
		
		/// <summary>
        /// nsICycleCollectorHandler is the interface JS code should implement to
        /// receive the results logged by a @mozilla.org/cycle-collector-logger;1
        /// instance. Pass an instance of this to the logger's 'processNext' method
        /// after the collection has run. This will describe the objects the cycle
        /// collector visited, the edges it found, and the conclusions it reached
        /// about the liveness of objects.
        ///
        /// In more detail:
        /// - For each node in the graph:
        /// - a call is made to either |noteRefCountedObject| or |noteGCedObject|, to
        /// describe the node itself; and
        /// - for each edge starting at that node, a call is made to |noteEdge|.
        ///
        /// - Then, a series of calls are made to:
        /// - |describeRoot|, for reference-counted nodes that the CC has identified as
        /// being alive because there are unknown references to those nodes.
        /// - |describeGarbage|, for nodes the cycle collector has identified as garbage.
        ///
        /// Any node not mentioned in a call to |describeRoot| or |describeGarbage| is
        /// neither a root nor garbage. The cycle collector was able to find all of the
        /// edges implied by the node's reference count.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteRefCountedObject([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, uint aRefCount, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aObjectDescription);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteGCedObject([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, [MarshalAs(UnmanagedType.U1)] bool aMarked, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aObjectDescription, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCompartmentAddress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteEdge([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aFromAddress, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aToAddress, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aEdgeName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeRoot([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, uint aKnownEdges);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeGarbage([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress);
	}
	
	/// <summary>
    /// This interface allows replacing the log-writing backend for an
    /// nsICycleCollectorListener.  As this interface is also called while
    /// the cycle collector is running, it cannot be implemented in JS.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3ad9875f-d0e4-4ac2-87e3-f127f6c02ce1")]
	public interface nsICycleCollectorLogSink
	{
		
		/// <summary>
        /// This interface allows replacing the log-writing backend for an
        /// nsICycleCollectorListener.  As this interface is also called while
        /// the cycle collector is running, it cannot be implemented in JS.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Open(ref System.IntPtr aGCLog, ref System.IntPtr aCCLog);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CloseGCLog();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CloseCCLog();
		
		/// <summary>
        /// This string will appear somewhere in the log's filename.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFilenameIdentifierAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aFilenameIdentifier);
		
		/// <summary>
        /// This string will appear somewhere in the log's filename.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFilenameIdentifierAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aFilenameIdentifier);
		
		/// <summary>
        /// of another process.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetProcessIdentifierAttribute();
		
		/// <summary>
        /// of another process.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetProcessIdentifierAttribute(int aProcessIdentifier);
		
		/// <summary>
        /// The GC log file, if logging to files.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIFile GetGcLogAttribute();
		
		/// <summary>
        /// The CC log file, if logging to files.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIFile GetCcLogAttribute();
	}
	
	/// <summary>
    /// This interface is used to configure some reporting options for the cycle
    /// collector. This interface cannot be implemented by JavaScript code, as it
    /// is called while the cycle collector is running.
    ///
    /// To analyze cycle collection data in JS:
    ///
    /// - Create an instance of @mozilla.org/cycle-collector-logger;1, which
    /// implements this interface.
    ///
    /// - Set its |disableLog| property to true. This prevents the logger from
    /// printing messages about each method call to a temporary log file.
    ///
    /// - Set its |wantAfterProcessing| property to true. This tells the logger
    /// to record calls to its methods in memory. The |processNext| method
    /// returns events from this record.
    ///
    /// - Perform a collection using the logger. For example, call
    /// |nsIDOMWindowUtils|'s |garbageCollect| method, passing the logger as
    /// the |aListener| argument.
    ///
    /// - When the collection is complete, loop calling the logger's
    /// |processNext| method, passing a JavaScript object that implements
    /// nsICycleCollectorHandler. This JS code is free to allocate and operate
    /// on objects however it pleases: the cycle collector has finished its
    /// work, and the JS code is simply consuming recorded data.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("703b53b6-24f6-40c6-9ea9-aeb2dc53d170")]
	public interface nsICycleCollectorListener
	{
		
		/// <summary>
        /// simply set a flag on this listener (a side effect!) and return it.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICycleCollectorListener AllTraces();
		
		/// <summary>
        /// True if this listener will behave like one returned by allTraces().
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetWantAllTracesAttribute();
		
		/// <summary>
        /// Initially false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetDisableLogAttribute();
		
		/// <summary>
        /// Initially false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisableLogAttribute([MarshalAs(UnmanagedType.U1)] bool aDisableLog);
		
		/// <summary>
        /// If |disableLog| is false, this object will be sent the log text.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICycleCollectorLogSink GetLogSinkAttribute();
		
		/// <summary>
        /// If |disableLog| is false, this object will be sent the log text.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetLogSinkAttribute([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorLogSink aLogSink);
		
		/// <summary>
        /// using |processNext|. Initially false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetWantAfterProcessingAttribute();
		
		/// <summary>
        /// using |processNext|. Initially false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetWantAfterProcessingAttribute([MarshalAs(UnmanagedType.U1)] bool aWantAfterProcessing);
		
		/// <summary>
        /// |wantAfterProcessing| property is true.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ProcessNext([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorHandler aHandler);
		
		/// <summary>
        /// concrete implementation type to help the GC rooting analysis.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr AsLogger();
	}
}
