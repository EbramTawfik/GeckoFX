// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICycleCollectorListener.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// The interface JS code should implement to receive annotations logged by an
    /// @mozilla.org/cycle-collector-logger;1 instance. Pass an instance of this to
    /// the logger's 'processNext' method.
    ///
    /// The methods are a subset of those in nsICycleCollectorListener; see the
    /// descriptions there.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("39a8f80e-7eee-4141-b9ef-6e2a7d6e466d")]
	public interface nsICycleCollectorHandler
	{
		
		/// <summary>
        /// The interface JS code should implement to receive annotations logged by an
        /// @mozilla.org/cycle-collector-logger;1 instance. Pass an instance of this to
        /// the logger's 'processNext' method.
        ///
        /// The methods are a subset of those in nsICycleCollectorListener; see the
        /// descriptions there.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteRefCountedObject([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, uint aRefCount, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aObjectDescription);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteGCedObject([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, [MarshalAs(UnmanagedType.U1)] bool aMarked, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aObjectDescription, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCompartmentAddress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteEdge([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aFromAddress, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aToAddress, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aEdgeName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeRoot([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress, uint aKnownEdges);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeGarbage([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aAddress);
	}
	
	/// <summary>
    /// Given an instance of this interface, the cycle collector calls the instance's
    /// methods to report the objects it visits, the edges between them, and its
    /// conclusions about which objects are roots and which are garbage.
    ///
    /// For a single cycle collection pass, the cycle collector calls this
    /// interface's methods in the following order:
    ///
    /// - First, |begin|. If |begin| returns an error, none of the listener's other
    /// methods will be called.
    ///
    /// - Then, for each node in the graph:
    /// - a call to either |noteRefCountedObject| or |noteGCedObject|, to describe
    /// the node itself; and
    /// - for each edge starting at that node, a call to |noteEdge|.
    ///
    /// - Then, zero or more calls to |noteIncrementalRoot|; an "incremental
    /// root" is an object that may have had a new reference to it created
    /// during an incremental collection, and must therefore be treated as
    /// live for safety.
    ///
    /// - After all the nodes have been described, a call to |beginResults|.
    ///
    /// - A series of calls to:
    /// - |describeRoot|, for reference-counted nodes that the CC has identified as
    /// roots of collection. (The cycle collector didn't find enough incoming
    /// edges to account for these nodes' reference counts, so there must be code
    /// holding on to them that the cycle collector doesn't know about.)
    /// - |describeGarbage|, for nodes the cycle collector has identified as garbage.
    ///
    /// Any node not mentioned in a call to |describeRoot| or |describeGarbage| is
    /// neither a root nor garbage. (The cycle collector was able to find all the
    /// edges implied by the node's reference count.)
    ///
    /// - Finally, a call to |end|.
    ///
    ///
    /// This interface cannot be implemented by JavaScript code, as it is called
    /// while the cycle collector works. To analyze cycle collection data in JS:
    ///
    /// - Create an instance of @mozilla.org/cycle-collector-logger;1, which
    /// implements this interface.
    ///
    /// - Set its |disableLog| property to true. This prevents the logger from
    /// printing messages about each method call to a temporary log file.
    ///
    /// - Set its |wantAfterProcessing| property to true. This tells the logger
    /// to record calls to its methods in memory. The |processNext| method
    /// returns events from this record.
    ///
    /// - Perform a collection using the logger. For example, call
    /// |nsIDOMWindowUtils|'s |garbageCollect| method, passing the logger as
    /// the |aListener| argument.
    ///
    /// - When the collection is complete, loop calling the logger's
    /// |processNext| method, passing a JavaScript object that implements
    /// nsICycleCollectorHandler. This JS code is free to allocate and operate
    /// on objects however it pleases: the cycle collector has finished its
    /// work, and the JS code is simply consuming recorded data.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("c46e6947-9076-4a0e-bb27-d4aa3706c54d")]
	public interface nsICycleCollectorListener
	{
		
		/// <summary>
        /// simply set a flag on this listener (a side effect!) and return it.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICycleCollectorListener AllTraces();
		
		/// <summary>
        /// True if this listener will behave like one returned by allTraces().
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetWantAllTracesAttribute();
		
		/// <summary>
        /// Initially false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetDisableLogAttribute();
		
		/// <summary>
        /// Initially false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisableLogAttribute([MarshalAs(UnmanagedType.U1)] bool aDisableLog);
		
		/// <summary>
        /// This string will appear somewhere in the log's filename.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFilenameIdentifierAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aFilenameIdentifier);
		
		/// <summary>
        /// This string will appear somewhere in the log's filename.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFilenameIdentifierAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aFilenameIdentifier);
		
		/// <summary>
        /// using |processNext|. Initially false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetWantAfterProcessingAttribute();
		
		/// <summary>
        /// using |processNext|. Initially false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetWantAfterProcessingAttribute([MarshalAs(UnmanagedType.U1)] bool aWantAfterProcessing);
		
		/// <summary>
        /// This string will indicate the full path of the GC log if enabled.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetGcLogPathAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aGcLogPath);
		
		/// <summary>
        /// This string will indicate the full path of the CC log if enabled.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetCcLogPathAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aCcLogPath);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Begin();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteRefCountedObject(ulong aAddress, uint aRefCount, [MarshalAs(UnmanagedType.LPStr)] string aObjectDescription);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteGCedObject(ulong aAddress, [MarshalAs(UnmanagedType.U1)] bool aMarked, [MarshalAs(UnmanagedType.LPStr)] string aObjectDescription, ulong aCompartmentAddress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteEdge(ulong aToAddress, [MarshalAs(UnmanagedType.LPStr)] string aEdgeName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteWeakMapEntry(ulong aMap, ulong aKey, ulong aKeyDelegate, ulong aValue);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteIncrementalRoot(ulong aAddress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BeginResults();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeRoot(ulong aAddress, uint aKnownEdges);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeGarbage(ulong aAddress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void End();
		
		/// <summary>
        /// |wantAfterProcessing| property is true.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ProcessNext([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorHandler aHandler);
	}
}
