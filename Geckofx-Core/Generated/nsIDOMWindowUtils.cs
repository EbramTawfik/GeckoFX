// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIDOMWindowUtils.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// nsIDOMWindowUtils is intended for infrequently-used methods related
    /// to the current nsIDOMWindow.  Some of the methods may require
    /// elevated privileges; the method implementations should contain the
    /// necessary security checks.  Access this interface by calling
    /// getInterface on a DOMWindow.
    ///
    /// WARNING: Do not use 'out jsval' parameters in this file.
    /// SpecialPowers, which is used to access nsIDOMWindowUtils
    /// in plain mochitests, does not know how to handle them.
    /// (Use 'jsval' return values instead.)
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("11911980-607c-4efd-aacc-de3b9005c058")]
	public interface nsIDOMWindowUtils
	{
		
		/// <summary>
        /// Image animation mode of the window. When this attribute's value
        /// is changed, the implementation should set all images in the window
        /// to the given value. That is, when set to kDontAnimMode, all images
        /// will stop animating. The attribute's value must be one of the
        /// animationMode values from imgIContainer.
        /// @note Images may individually override the window's setting after
        /// the window's mode is set. Therefore images given different modes
        /// since the last setting of the window's mode may behave
        /// out of line with the window's overall mode.
        /// @note The attribute's value is the window's overall mode. It may
        /// for example continue to report kDontAnimMode after all images
        /// have subsequently been individually animated.
        /// @note Only images immediately in this window are affected;
        /// this is not recursive to subwindows.
        /// @see imgIContainer
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ushort GetImageAnimationModeAttribute();
		
		/// <summary>
        /// Image animation mode of the window. When this attribute's value
        /// is changed, the implementation should set all images in the window
        /// to the given value. That is, when set to kDontAnimMode, all images
        /// will stop animating. The attribute's value must be one of the
        /// animationMode values from imgIContainer.
        /// @note Images may individually override the window's setting after
        /// the window's mode is set. Therefore images given different modes
        /// since the last setting of the window's mode may behave
        /// out of line with the window's overall mode.
        /// @note The attribute's value is the window's overall mode. It may
        /// for example continue to report kDontAnimMode after all images
        /// have subsequently been individually animated.
        /// @note Only images immediately in this window are affected;
        /// this is not recursive to subwindows.
        /// @see imgIContainer
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetImageAnimationModeAttribute(ushort aImageAnimationMode);
		
		/// <summary>
        /// Whether the charset of the window's current document has been forced by
        /// the user.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetDocCharsetIsForcedAttribute();
		
		/// <summary>
        /// Get current cursor type from this window
        /// @return the current value of nsCursor
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		short GetCursorType();
		
		/// <summary>
        /// Function to get metadata associated with the window's current document
        /// @param aName the name of the metadata.  This should be all lowercase.
        /// @return the value of the metadata, or the empty string if it's not set
        ///
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDocumentMetadata([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// Force an immediate redraw of this window.  The parameter specifies
        /// the number of times to redraw, and the return value is the length,
        /// in milliseconds, that the redraws took.  If aCount is not specified
        /// or is 0, it is taken to be 1.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint Redraw(uint aCount);
		
		/// <summary>
        /// Set the CSS viewport to be |widthPx| x |heightPx| in units of CSS
        /// pixels, regardless of the size of the enclosing widget/view.
        /// This will trigger reflow.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCSSViewport(float aWidthPx, float aHeightPx);
		
		/// <summary>
        /// Information retrieved from the <meta name="viewport"> tag.
        /// See nsContentUtils::GetViewportInfo for more information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetViewportInfo(uint aDisplayWidth, uint aDisplayHeight, ref double aDefaultZoom, [MarshalAs(UnmanagedType.U1)] ref bool aAllowZoom, ref double aMinZoom, ref double aMaxZoom, ref uint aWidth, ref uint aHeight, [MarshalAs(UnmanagedType.U1)] ref bool aAutoSize);
		
		/// <summary>
        /// For any scrollable element, this allows you to override the
        /// visible region and draw more than what is visible, which is
        /// useful for asynchronous drawing. The "displayport" will be
        /// <xPx, yPx, widthPx, heightPx> in units of CSS pixels,
        /// regardless of the size of the enclosing container.  This
        /// will *not* trigger reflow.
        ///
        /// For the root scroll area, pass in the root document element.
        /// For scrollable elements, pass in the container element (for
        /// instance, the element with overflow: scroll).
        ///
        /// <x, y> is relative to the top-left of what would normally be
        /// the visible area of the element. This means that the pixels
        /// rendered to the displayport take scrolling into account,
        /// for example.
        ///
        /// It's legal to set a displayport that extends beyond the overflow
        /// area in any direction (left/right/top/bottom).
        ///
        /// It's also legal to set a displayport that extends beyond the
        /// area's bounds.  No pixels are rendered outside the area bounds.
        ///
        /// The caller of this method must have chrome privileges.
        ///
        /// Calling this will always force a recomposite, so it should be
        /// avoided if at all possible. Client code should do checks before
        /// calling this so that duplicate sets are not made with the same
        /// displayport.
        ///
        /// aPriority is recorded along with the displayport rectangle. If this
        /// method is called with a lower priority than the current priority, the
        /// call is ignored.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisplayPortForElement(float aXPx, float aYPx, float aWidthPx, float aHeightPx, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement, uint aPriority);
		
		/// <summary>
        /// An alternate way to represent a displayport rect as a set of margins and a
        /// base rect to apply those margins to. A consumer of pixels may ask for as
        /// many extra pixels as it would like in each direction. Layout then sets
        /// the base rect to the "visible rect" of the element, which is just the
        /// subrect of the element that is drawn (it does not take in account content
        /// covering the element).
        ///
        /// If both a displayport rect and displayport margins with corresponding base
        /// rect are set with the same priority then the margins will take precendence.
        ///
        /// Specifying an alignment value will ensure that after the base rect has
        /// been expanded by the displayport margins, it will be further expanded so
        /// that each edge is located at a multiple of the "alignment" value.
        ///
        /// Note that both the margin values and alignment are treated as values in
        /// LayerPixels. Refer to layout/base/Units.h for a description of this unit.
        /// The base rect values are in app units.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisplayPortMarginsForElement(float aLeftMargin, float aTopMargin, float aRightMargin, float aBottomMargin, uint aAlignmentX, uint aAlignmentY, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement, uint aPriority);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisplayPortBaseForElement(int aX, int aY, int aWidth, int aHeight, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Get/set the resolution at which rescalable web content is drawn.
        /// Currently this is only (some) thebes content.
        ///
        /// Setting a new resolution does *not* trigger reflow.  This API is
        /// entirely separate from textZoom and fullZoom; a resolution scale
        /// can be applied together with both textZoom and fullZoom.
        ///
        /// The effect of is API for gfx code to allocate more or fewer
        /// pixels for rescalable content by a factor of |resolution| in
        /// either or both dimensions.  setResolution() together with
        /// setDisplayport() can be used to implement a non-reflowing
        /// scale-zoom in concert with another entity that can draw with a
        /// scale.  For example, to scale a content |window| inside a
        /// <browser> by a factor of 2.0
        ///
        /// window.setDisplayport(x, y, oldW / 2.0, oldH / 2.0);
        /// window.setResolution(2.0, 2.0);
        /// // elsewhere
        /// browser.setViewportScale(2.0, 2.0);
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetResolution(float aXResolution, float aYResolution);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetResolution(ref float aXResolution, ref float aYResolution);
		
		/// <summary>
        /// Whether the resolution has been set by the user.
        /// This gives a way to check whether the provided resolution is the default
        /// value or restored from a previous session.
        ///
        /// Can only be accessed with chrome privileges.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsResolutionSetAttribute();
		
		/// <summary>
        /// Whether the next paint should be flagged as the first paint for a document.
        /// This gives a way to track the next paint that occurs after the flag is
        /// set. The flag gets cleared after the next paint.
        ///
        /// Can only be accessed with chrome privileges.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsFirstPaintAttribute();
		
		/// <summary>
        /// Whether the next paint should be flagged as the first paint for a document.
        /// This gives a way to track the next paint that occurs after the flag is
        /// set. The flag gets cleared after the next paint.
        ///
        /// Can only be accessed with chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsFirstPaintAttribute([MarshalAs(UnmanagedType.U1)] bool aIsFirstPaint);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPresShellId(ref uint aPresShellId);
		
		/// <summary>
        ///Synthesize a mouse event. The event types supported are:
        /// mousedown, mouseup, mousemove, mouseover, mouseout, contextmenu,
        /// MozMouseHitTest
        ///
        /// Events are sent in coordinates offset by aX and aY from the window.
        ///
        /// Note that additional events may be fired as a result of this call. For
        /// instance, typically a click event will be fired as a result of a
        /// mousedown and mouseup in sequence.
        ///
        /// Normally at this level of events, the mouseover and mouseout events are
        /// only fired when the window is entered or exited. For inter-element
        /// mouseover and mouseout events, a movemove event fired on the new element
        /// should be sufficient to generate the correct over and out events as well.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// The event is dispatched via the toplevel window, so it could go to any
        /// window under the toplevel window, in some cases it could never reach this
        /// window at all.
        ///
        /// @param aType event type
        /// @param aX x offset in CSS pixels
        /// @param aY y offset in CSS pixels
        /// @param aButton button to synthesize
        /// @param aClickCount number of clicks that have been performed
        /// @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
        /// @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
        /// during dispatch
        /// @param aPressure touch input pressure: 0.0 -> 1.0
        /// @param aInputSourceArg input source, see nsIDOMMouseEvent for values,
        /// defaults to mouse input.
        /// @param aIsSynthesized controls nsIDOMEvent.isSynthesized value
        /// that helps identifying test related events,
        /// defaults to true
        ///
        /// returns true if the page called prevent default on this event
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendMouseEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, float aX, float aY, int aButton, int aClickCount, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, float aPressure, ushort aInputSourceArg, [MarshalAs(UnmanagedType.U1)] bool aIsSynthesized, int argc);
		
		/// <summary>
        ///Synthesize a pointer event. The event types supported are:
        /// pointerdown, pointerup, pointermove, pointerover, pointerout
        ///
        /// Events are sent in coordinates offset by aX and aY from the window.
        ///
        /// Note that additional events may be fired as a result of this call. For
        /// instance, typically a click event will be fired as a result of a
        /// mousedown and mouseup in sequence.
        ///
        /// Normally at this level of events, the pointerover and pointerout events are
        /// only fired when the window is entered or exited. For inter-element
        /// pointerover and pointerout events, a movemove event fired on the new element
        /// should be sufficient to generate the correct over and out events as well.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// The event is dispatched via the toplevel window, so it could go to any
        /// window under the toplevel window, in some cases it could never reach this
        /// window at all.
        ///
        /// @param aType event type
        /// @param aX x offset in CSS pixels
        /// @param aY y offset in CSS pixels
        /// @param aButton button to synthesize
        /// @param aClickCount number of clicks that have been performed
        /// @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
        /// @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
        /// during dispatch
        /// @param aPressure touch input pressure: 0.0 -> 1.0
        /// @param aInputSourceArg input source, see nsIDOMMouseEvent for values,
        /// defaults to mouse input.
        /// @param aPointerId A unique identifier for the pointer causing the event. default is 0
        /// @param aWidth The width (magnitude on the X axis), default is 0
        /// @param aHeight The height (magnitude on the Y axis), default is 0
        /// @param aTilt The plane angle between the Y-Z plane
        /// and the plane containing both the transducer (e.g. pen stylus) axis and the Y axis. default is 0
        /// @param aTiltX The plane angle between the X-Z plane
        /// and the plane containing both the transducer (e.g. pen stylus) axis and the X axis. default is 0
        /// @param aIsPrimary  Indicates if the pointer represents the primary pointer of this pointer type.
        /// @param aIsSynthesized controls nsIDOMEvent.isSynthesized value
        /// that helps identifying test related events,
        /// defaults to true
        ///
        /// returns true if the page called prevent default on this event
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendPointerEvent(
					[MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, 
					float aX, 
					float aY, 
					int aButton, 
					int aClickCount, 
					int aModifiers, 
					[MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, 
					float aPressure, 
					ushort aInputSourceArg, 
					int aPointerId, 
					int aWidth, 
					int aHeight, 
					int aTiltX, 
					int aTiltY, 
					[MarshalAs(UnmanagedType.U1)] bool aIsPrimary, 
					[MarshalAs(UnmanagedType.U1)] bool aIsSynthesized, 
					int argc);
		
		/// <summary>
        ///Synthesize a touch event. The event types supported are:
        /// touchstart, touchend, touchmove, and touchcancel
        ///
        /// Events are sent in coordinates offset by aX and aY from the window.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// The event is dispatched via the toplevel window, so it could go to any
        /// window under the toplevel window, in some cases it could never reach this
        /// window at all.
        ///
        /// @param aType event type
        /// @param xs array of offsets in CSS pixels for each touch to be sent
        /// @param ys array of offsets in CSS pixels for each touch to be sent
        /// @param rxs array of radii in CSS pixels for each touch to be sent
        /// @param rys array of radii in CSS pixels for each touch to be sent
        /// @param rotationAngles array of angles in degrees for each touch to be sent
        /// @param forces array of forces (floats from 0 to 1) for each touch to be sent
        /// @param count number of touches in this set
        /// @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
        /// @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
        /// during dispatch
        ///
        /// returns true if the page called prevent default on this touch event
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendTouchEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aIdentifiers, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aXs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aYs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRxs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRys, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aRotationAngles, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aForces, uint count, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame);
		
		/// <summary>
        ///The same as sendMouseEvent but ensures that the event is dispatched to
        /// this DOM window or one of its children.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendMouseEventToWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, float aX, float aY, int aButton, int aClickCount, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, float aPressure, ushort aInputSourceArg, [MarshalAs(UnmanagedType.U1)] bool aIsSynthesized, int argc);
		
		/// <summary>
        ///The same as sendPointerEvent but ensures that the event
        /// is dispatched to this DOM window or one of its children.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendPointerEventToWindow(
					[MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, 
					float aX, 
					float aY, 
					int aButton, 
					int aClickCount, 
					int aModifiers, 
					[MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, 
					float aPressure, 
					ushort aInputSourceArg, 
					int aPointerId, 
					int aWidth, 
					int aHeight, 
					int aTiltX, 
					int aTiltY, 
					[MarshalAs(UnmanagedType.U1)] bool aIsPrimary, 
					[MarshalAs(UnmanagedType.U1)] bool aIsSynthesized, 
					int argc);
		
		/// <summary>
        ///The same as sendTouchEvent but ensures that the event is dispatched to
        /// this DOM window or one of its children.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendTouchEventToWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aIdentifiers, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aXs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aYs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRxs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRys, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aRotationAngles, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aForces, uint count, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendWheelEvent(float aX, float aY, double aDeltaX, double aDeltaY, double aDeltaZ, uint aDeltaMode, int aModifiers, int aLineOrPageDeltaX, int aLineOrPageDeltaY, uint aOptions);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendKeyEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, int aKeyCode, int aCharCode, int aModifiers, uint aAdditionalFlags);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeKeyEvent
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// When you use this for tests, use the constants defined in NativeKeyCodes.js
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeKeyEvent(int aNativeKeyboardLayout, int aNativeKeyCode, int aModifierFlags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aCharacters, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aUnmodifiedCharacters);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeMouseEvent
        ///
        /// Will be called on the widget that contains aElement.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeMouseEvent(int aScreenX, int aScreenY, int aNativeMessage, int aModifierFlags, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeMouseScrollEvent
        ///
        /// Will be called on the widget that contains aElement.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// NOTE: The synthesized native event may be fired asynchronously.
        ///
        /// @param aNativeMessage
        /// On Windows:  WM_MOUSEWHEEL (0x020A), WM_MOUSEHWHEEL(0x020E),
        /// WM_VSCROLL (0x0115) or WM_HSCROLL (0x114).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeMouseScrollEvent(int aScreenX, int aScreenY, uint aNativeMessage, double aDeltaX, double aDeltaY, double aDeltaZ, uint aModifierFlags, uint aAdditionalFlags, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Create a new or update an existing touch point on the digitizer.
        /// To trigger os level gestures, individual touch points should
        /// transition through a complete set of touch states which should be
        /// sent as individual calls. For example:
        /// tap - msg1:TOUCH_CONTACT, msg2:TOUCH_REMOVE
        /// drag - msg1-n:TOUCH_CONTACT (moving), msgn+1:TOUCH_REMOVE
        /// hover drag - msg1-n:TOUCH_HOVER (moving), msgn+1:TOUCH_REMOVE
        ///
        /// Widget support: Windows 8.0+, Winrt/Win32. Other widgets will
        /// throw.
        ///
        /// @param aPointerId The touch point id to create or update.
        /// @param aTouchState one or more of the touch states listed above
        /// @param aScreenX, aScreenY screen coords of this event
        /// @param aPressure 0.0 -> 1.0 float val indicating pressure
        /// @param aOrientation 0 -> 359 degree value indicating the
        /// orientation of the pointer. Use 90 for normal taps.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeTouchPoint(uint aPointerId, uint aTouchState, int aScreenX, int aScreenY, double aPressure, uint aOrientation);
		
		/// <summary>
        /// Simulates native touch based taps on the input digitizer. Events
        /// triggered by this call are injected at the os level. Events do not
        /// bypass widget level input processing and as such can be used to
        /// test widget event logic and async pan-zoom controller functionality.
        /// Cannot be accessed from an unprivileged context.
        ///
        /// Long taps (based on the aLongTap parameter) will be completed
        /// asynchrnously after the call returns. Long tap delay is based on
        /// the ui.click_hold_context_menus.delay pref or 1500 msec if pref
        /// is not set.
        ///
        /// Widget support: Windows 8.0+, Winrt/Win32. Other widgets will
        /// throw.
        ///
        /// @param aScreenX, aScreenY screen coords of this event
        /// @param aLongTap true if the tap should be long, false for a short
        /// tap.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeTouchTap(int aScreenX, int aScreenY, [MarshalAs(UnmanagedType.U1)] bool aLongTap);
		
		/// <summary>
        /// Cancel any existing touch points or long tap delays. Calling this is safe
        /// even if you're sure there aren't any pointers recorded. You should call
        /// this when tests shut down to reset the digitizer driver. Not doing so can
        /// leave the digitizer in an undetermined state which can screw up subsequent
        /// tests and native input.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearNativeTouchSequence();
		
		/// <summary>
        /// See nsIWidget::ActivateNativeMenuItemAt
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ActivateNativeMenuItemAt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase indexString);
		
		/// <summary>
        /// See nsIWidget::ForceUpdateNativeMenuAt
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ForceUpdateNativeMenuAt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase indexString);
		
		/// <summary>
        /// Focus the element aElement. The element should be in the same document
        /// that the window is displaying. Pass null to blur the element, if any,
        /// that currently has focus, and focus the document.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aElement the element to focus
        ///
        /// Do not use this method. Just use element.focus if available or
        /// nsIFocusManager::SetFocus instead.
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Focus([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Force a garbage collection followed by a cycle collection.
        ///
        /// Will throw a DOM security error if called without chrome privileges in
        /// non-debug builds. Available to all callers in debug builds.
        ///
        /// @param aListener listener that receives information about the CC graph
        /// (see @mozilla.org/cycle-collector-logger;1 for a logger
        /// component)
        /// @param aExtraForgetSkippableCalls indicates how many times
        /// nsCycleCollector_forgetSkippable will
        /// be called before running cycle collection.
        /// -1 prevents the default
        /// nsCycleCollector_forgetSkippable call
        /// which happens after garbage collection.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GarbageCollect([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorListener aListener, int aExtraForgetSkippableCalls);
		
		/// <summary>
        /// Force a cycle collection without garbage collection.
        ///
        /// Will throw a DOM security error if called without chrome privileges in
        /// non-debug builds. Available to all callers in debug builds.
        ///
        /// @param aListener listener that receives information about the CC graph
        /// (see @mozilla.org/cycle-collector-logger;1 for a logger
        /// component)
        /// @param aExtraForgetSkippableCalls indicates how many times
        /// nsCycleCollector_forgetSkippable will
        /// be called before running cycle collection.
        /// -1 prevents the default
        /// nsCycleCollector_forgetSkippable call
        /// which happens after garbage collection.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CycleCollect([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorListener aListener, int aExtraForgetSkippableCalls);
		
		/// <summary>
        /// Trigger whichever GC or CC timer is currently active and waiting to fire.
        /// Don't do this too much for initiating heavy actions, like the start of a IGC.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RunNextCollectorTimer();
		
		/// <summary>
        ///Synthesize a simple gesture event for a window. The event types
        /// supported are: MozSwipeGestureStart, MozSwipeGestureUpdate,
        /// MozSwipeGestureEnd, MozSwipeGesture, MozMagnifyGestureStart,
        /// MozMagnifyGestureUpdate, MozMagnifyGesture, MozRotateGestureStart,
        /// MozRotateGestureUpdate, MozRotateGesture, MozPressTapGesture,
        /// MozTapGesture, and MozEdgeUIGesture.
        ///
        /// Cannot be accessed from unprivileged context (not
        /// content-accessible) Will throw a DOM security error if called
        /// without chrome privileges.
        ///
        /// @param aType event type
        /// @param aX x offset in CSS pixels
        /// @param aY y offset in CSS pixels
        /// @param aDirection direction, using constants defined in nsIDOMSimpleGestureEvent
        /// @param aDelta  amount of magnification or rotation for magnify and rotation events
        /// @param aModifiers modifiers pressed, using constants defined in nsIDOMNSEvent
        /// @param aClickCount For tap gestures, the number of taps.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendSimpleGestureEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, float aX, float aY, uint aDirection, double aDelta, int aModifiers, uint aClickCount);
		
		/// <summary>
        /// Retrieve the element at point aX, aY in the window's document.
        ///
        /// @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
        /// frame when retrieving the element. If false, this method returns
        /// null for coordinates outside of the viewport.
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMElement ElementFromPoint(float aX, float aY, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, [MarshalAs(UnmanagedType.U1)] bool aFlushLayout);
		
		/// <summary>
        /// Retrieve all nodes that intersect a rect in the window's document.
        ///
        /// @param aX x reference for the rectangle in CSS pixels
        /// @param aY y reference for the rectangle in CSS pixels
        /// @param aTopSize How much to expand up the rectangle
        /// @param aRightSize How much to expand right the rectangle
        /// @param aBottomSize How much to expand down the rectangle
        /// @param aLeftSize How much to expand left the rectangle
        /// @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
        /// frame when retrieving the element. If false, this method returns
        /// null for coordinates outside of the viewport.
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMNodeList NodesFromRect(float aX, float aY, float aTopSize, float aRightSize, float aBottomSize, float aLeftSize, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, [MarshalAs(UnmanagedType.U1)] bool aFlushLayout);
		
		/// <summary>
        /// Get a list of nodes that have meaningful textual content to
        /// be translated. The implementation of this algorithm is in flux
        /// as we experiment and refine which approach works best.
        ///
        /// This method requires chrome privileges.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsITranslationNodeList GetTranslationNodes([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aRoot);
		
		/// <summary>
        /// Compare the two canvases, returning the number of differing pixels and
        /// the maximum difference in a channel.  This will throw an error if
        /// the dimensions of the two canvases are different.
        ///
        /// This method requires chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint CompareCanvases([MarshalAs(UnmanagedType.Interface)] nsIDOMHTMLCanvasElement aCanvas1, [MarshalAs(UnmanagedType.Interface)] nsIDOMHTMLCanvasElement aCanvas2, ref uint aMaxDifference);
		
		/// <summary>
        /// Returns true if a MozAfterPaint event has been queued but not yet
        /// fired.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsMozAfterPaintPendingAttribute();
		
		/// <summary>
        /// Suppresses/unsuppresses user initiated event handling in window's document
        /// and subdocuments.
        ///
        /// @throw NS_ERROR_DOM_SECURITY_ERR if called without chrome privileges and
        /// NS_ERROR_FAILURE if window doesn't have a document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SuppressEventHandling([MarshalAs(UnmanagedType.U1)] bool aSuppress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearMozAfterPaintEvents();
		
		/// <summary>
        /// Disable or enable non synthetic test mouse events on *all* windows.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible).
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aDisable  If true, disable all non synthetic test mouse events
        /// on all windows.  Otherwise, enable them.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DisableNonTestMouseEvents([MarshalAs(UnmanagedType.U1)] bool aDisable);
		
		/// <summary>
        /// Returns the scroll position of the window's currently loaded document.
        ///
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// @see nsIDOMWindow::scrollX/Y
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetScrollXY([MarshalAs(UnmanagedType.U1)] bool aFlushLayout, ref int aScrollX, ref int aScrollY);
		
		/// <summary>
        /// Returns the scroll position of the window's currently loaded document.
        ///
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// @see nsIDOMWindow::scrollX/Y
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetScrollXYFloat([MarshalAs(UnmanagedType.U1)] bool aFlushLayout, ref float aScrollX, ref float aScrollY);
		
		/// <summary>
        /// Returns the scrollbar width of the window's scroll frame.
        ///
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetScrollbarSize([MarshalAs(UnmanagedType.U1)] bool aFlushLayout, ref int aWidth, ref int aHeight);
		
		/// <summary>
        /// Returns the given element's bounds without flushing pending layout changes.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMClientRect GetBoundsWithoutFlushing([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Returns the bounds of the window's currently loaded document. This will
        /// generally be (0, 0, pageWidth, pageHeight) but in some cases (e.g. RTL
        /// documents) may have a negative left value.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMClientRect GetRootBounds();
		
		/// <summary>
        /// Get IME open state. TRUE means 'Open', otherwise, 'Close'.
        /// This property works only when IMEEnabled is IME_STATUS_ENABLED.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIMEIsOpenAttribute();
		
		/// <summary>
        /// Get IME status, see above IME_STATUS_* definitions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetIMEStatusAttribute();
		
		/// <summary>
        /// Get the number of screen pixels per CSS pixel.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetScreenPixelsPerCSSPixelAttribute();
		
		/// <summary>
        /// Get the current zoom factor.
        /// This is _approximately_ the same as nsIMarkupDocumentViewer.fullZoom,
        /// but takes into account Gecko's quantization of the zoom factor, which is
        /// implemented by adjusting the (integer) number of appUnits per devPixel.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetFullZoomAttribute();
		
		/// <summary>
        /// Dispatches aEvent via the nsIPresShell object of the window's document.
        /// The event is dispatched to aTarget, which should be an object
        /// which implements nsIContent interface (#element, #text, etc).
        ///
        /// Cannot be accessed from unprivileged context (not
        /// content-accessible) Will throw a DOM security error if called
        /// without chrome privileges.
        ///
        /// @note Event handlers won't get aEvent as parameter, but a similar event.
        /// Also, aEvent should not be reused.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool DispatchDOMEventViaPresShell([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aTarget, [MarshalAs(UnmanagedType.Interface)] nsIDOMEvent aEvent, [MarshalAs(UnmanagedType.U1)] bool aTrusted);
		
		/// <summary>
        /// Sets WidgetEvent::mFlags::mOnlyChromeDispatch to true to ensure that
        /// the event is propagated only to chrome.
        /// Event's .target property will be aTarget.
        /// Returns the same value as what EventTarget.dispatchEvent does.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool DispatchEventToChromeOnly([MarshalAs(UnmanagedType.Interface)] nsIDOMEventTarget aTarget, [MarshalAs(UnmanagedType.Interface)] nsIDOMEvent aEvent);
		
		/// <summary>
        /// Returns the real classname (possibly of the mostly-transparent security
        /// wrapper) of aObj.
        /// </summary>
		[return: MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.StringMarshaler")]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetClassName(ref Gecko.JsVal aObject, System.IntPtr jsContext);
		
		/// <summary>
        /// Generate a content command event.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aType Type of command content event to send.  Can be one of "cut",
        /// "copy", "paste", "delete", "undo", "redo", or "pasteTransferable".
        /// @param aTransferable an instance of nsITransferable when aType is
        /// "pasteTransferable"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendContentCommandEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, [MarshalAs(UnmanagedType.Interface)] nsITransferable aTransferable);
		
		/// <summary>
        /// Synthesize a composition event to the window.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aType     The event type: "compositionstart", "compositionend" or
        /// "compositionupdate".
        /// @param aData     The data property value.  Note that this isn't applied
        /// for compositionstart event because its value is the
        /// selected text which is automatically computed.
        /// @param aLocale   The locale property value.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendCompositionEvent([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aType, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aData, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aLocale);
		
		/// <summary>
        /// Creating synthesizer of composition string on the window.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICompositionStringSynthesizer CreateCompositionStringSynthesizer();
		
		/// <summary>
        /// Synthesize a query content event. Note that the result value returned here
        /// is in LayoutDevice pixels rather than CSS pixels.
        ///
        /// @param aType  One of the following const values.  And see also each comment
        /// for the other parameters and the result.
        /// @param aAdditionalFlags See the description of QUERY_CONTENT_FLAG_*.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIQueryContentEventResult SendQueryContentEvent(uint aType, uint aOffset, uint aLength, int aX, int aY, uint aAdditionalFlags);
		
		/// <summary>
        /// Called when the remote child frame has changed its fullscreen state,
        /// when entering fullscreen, and when the origin which is fullscreen changes.
        /// aFrameElement is the iframe element which contains the child-process
        /// fullscreen document, and aNewOrigin is the origin of the new fullscreen
        /// document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoteFrameFullscreenChanged([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aFrameElement, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aNewOrigin);
		
		/// <summary>
        /// Called when the remote frame has popped all fullscreen elements off its
        /// stack, so that the operation can complete on the parent side.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoteFrameFullscreenReverted();
		
		/// <summary>
        /// Called when the child frame has fully exit fullscreen, so that the parent
        /// process can also fully exit.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ExitFullscreen();
		
		/// <summary>
        /// Synthesize a selection set event to the window.
        ///
        /// This sets the selection as the specified information.
        ///
        /// @param aOffset  The caret offset of the selection start.
        /// @param aLength  The length of the selection.  If this is too long, the
        /// extra length is ignored.
        /// @param aAdditionalFlags See the description of SELECTION_SET_FLAG_*.
        /// @return True, if succeeded.  Otherwise, false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendSelectionSetEvent(uint aOffset, uint aLength, uint aAdditionalFlags);
		
		/// <summary>
        /// Select content at a client point based on a selection behavior if the
        /// underlying content is selectable. Selection will accumulate with any
        /// existing selection, callers should clear selection prior if needed.
        /// May fire selection changed events. Calls nsFrame's SelectByTypeAtPoint.
        ///
        /// @param aX, aY The selection point in client coordinates.
        /// @param aSelectType The selection behavior requested.
        /// @return True if a selection occured, false otherwise.
        /// @throw NS_ERROR_DOM_SECURITY_ERR, NS_ERROR_UNEXPECTED for utils
        /// issues, and NS_ERROR_INVALID_ARG for coordinates that are outside
        /// this window.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SelectAtPoint(float aX, float aY, uint aSelectBehavior);
		
		/// <summary>
        /// Perform the equivalent of:
        /// window.getComputedStyle(aElement, aPseudoElement).
        /// getPropertyValue(aPropertyName)
        /// except that, when the link whose presence in history is allowed to
        /// influence aElement's style is visited, get the value the property
        /// would have if allowed all properties to change as a result of
        /// :visited selectors (except for cases where getComputedStyle uses
        /// data from the frame).
        ///
        /// This is easier to implement than adding our property restrictions
        /// to this API, and is sufficient for the present testing
        /// requirements (which are essentially testing 'color').
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetVisitedDependentComputedStyle([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aPseudoElement, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aPropertyName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// Returns the parent of obj.
        ///
        /// @param obj The JavaScript object whose parent is to be gotten.
        /// @return the parent.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetParent(ref Gecko.JsVal obj, System.IntPtr jsContext);
		
		/// <summary>
        /// Get the id of the outer window of this window.  This will never throw.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ulong GetOuterWindowIDAttribute();
		
		/// <summary>
        /// Get the id of the current inner window of this window.  If there
        /// is no current inner window, throws NS_ERROR_NOT_AVAILABLE.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ulong GetCurrentInnerWindowIDAttribute();
		
		/// <summary>
        /// Put the window into a state where scripts are frozen and events
        /// suppressed, for use when the window has launched a modal prompt.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnterModalState();
		
		/// <summary>
        /// Resume normal window state, where scripts can run and events are
        /// delivered.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LeaveModalState();
		
		/// <summary>
        /// Is the window is in a modal state? [See enterModalState()]
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsInModalState();
		
		/// <summary>
        /// Suspend/resume timeouts on this window and its descendant windows.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SuspendTimeouts();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ResumeTimeouts();
		
		/// <summary>
        /// What type of layer manager the widget associated with this window is
        /// using. "Basic" is unaccelerated; other types are accelerated. Throws an
        /// error if there is no widget associated with this window.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLayerManagerTypeAttribute([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aLayerManagerType);
		
		/// <summary>
        /// True if the layer manager for the widget associated with this window is
        /// forwarding layers to a remote compositor, false otherwise. Throws an
        /// error if there is no widget associated with this window.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetLayerManagerRemoteAttribute();
		
		/// <summary>
        /// Returns a handle which represents current recording start position.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint StartFrameTimeRecording();
		
		/// <summary>
        /// Returns number of recorded frames since startIndex was issued,
        /// and allocates+populates 2 arraye with the recorded data.
        /// - Allocation is infallible. Should be released even if size is 0.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopFrameTimeRecording(uint startIndex, ref uint frameCount, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] ref float[] frameIntervals);
		
		/// <summary>
        /// Signals that we're begining to tab switch. This is used by painting code to
        /// determine total tab switch time.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BeginTabSwitch();
		
		/// <summary>
        /// The DPI of the display
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetDisplayDPIAttribute();
		
		/// <summary>
        /// Return the outer window with the given ID, if any.  Can return null.
        /// @deprecated Use nsIWindowMediator.getOuterWindowWithId.  See bug 865664.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetOuterWindowWithId(ulong aOuterWindowID);
		
		/// <summary>
        /// Return this window's frame element.
        /// Ignores all chrome/content or mozbrowser boundaries.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMElement GetContainerElementAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RenderDocument(nsConstRect aRect, uint aFlags, nscolor aBackgroundColor, gfxContext aThebesContext);
		
		/// <summary>
        /// advanceTimeAndRefresh allows the caller to take over the refresh
        /// driver timing for a window.  A call to advanceTimeAndRefresh does
        /// three things:
        /// (1) It marks the refresh driver for this presentation so that it
        /// no longer refreshes on its own, but is instead driven entirely
        /// by the caller (except for the refresh that happens when a
        /// document comes out of the bfcache).
        /// (2) It advances the refresh driver's current refresh time by the
        /// argument given.  Negative advances are permitted.
        /// (3) It does a refresh (i.e., notifies refresh observers) at that
        /// new time.
        ///
        /// Note that this affects other connected docshells of the same type
        /// in the same docshell tree, such as parent frames.
        ///
        /// When callers have completed their use of advanceTimeAndRefresh,
        /// they must call restoreNormalRefresh.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AdvanceTimeAndRefresh(long aMilliseconds);
		
		/// <summary>
        /// Undoes the effects of advanceTimeAndRefresh.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RestoreNormalRefresh();
		
		/// <summary>
        /// Reports whether the current state is test-controlled refreshes
        /// (see advanceTimeAndRefresh and restoreNormalRefresh above).
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsTestControllingRefreshesAttribute();
		
		/// <summary>
        /// Set async scroll offset on an element. The next composite will render
        /// with that offset if async scrolling is enabled, and then the offset
        /// will be removed. Only call this while test-controlled refreshes is enabled.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAsyncScrollOffset([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aNode, int aX, int aY);
		
		/// <summary>
        /// Method for testing StyleAnimationValue::ComputeDistance.
        ///
        /// Returns the distance between the two values as reported by
        /// StyleAnimationValue::ComputeDistance for the given element and
        /// property.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double ComputeAnimationDistance([MarshalAs(UnmanagedType.Interface)] nsIDOMElement element, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase property, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase value1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase value2);
		
		/// <summary>
        /// Wrap an nsIFile in an nsIDOMFile
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMFile WrapDOMFile([MarshalAs(UnmanagedType.Interface)] nsIFile aFile);
		
		/// <summary>
        /// Get the type of the currently focused html input, if any.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetFocusedInputTypeAttribute();
		
		/// <summary>
        /// Given a view ID from the compositor process, retrieve the element
        /// associated with a view. For scrollpanes for documents, the root
        /// element of the document is returned.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMElement FindElementWithViewId(System.IntPtr aId);
		
		/// <summary>
        /// Find the view ID for a given element. This is the reverse of
        /// findElementWithViewId().
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetViewId([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Checks the layer tree for this window and returns true
        /// if all layers have transforms that are translations by integers,
        /// no leaf layers overlap, and the union of the leaf layers is exactly
        /// the bounds of the window. Always returns true in non-DEBUG builds.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool LeafLayersPartitionWindow();
		
		/// <summary>
        /// true if the (current inner) window may have event listeners for touch events.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetMayHaveTouchEventListenersAttribute();
		
		/// <summary>
        /// Check if any ThebesLayer painting has been done for this element,
        /// clears the painted flags if they have.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool CheckAndClearPaintedState([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Get internal id of the stored blob, file or file handle.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetFileId(ref Gecko.JsVal aFile, System.IntPtr jsContext);
		
		/// <summary>
        /// Get file ref count info for given database and file id.
        ///
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetFileReferences([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aDatabaseName, long aId, ref Gecko.JsVal aOptions, ref int aRefCnt, ref int aDBRefCnt, ref int aSliceRefCnt, System.IntPtr jsContext);
		
		/// <summary>
        /// Return whether incremental GC has been disabled due to a binary add-on.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsIncrementalGCEnabled(System.IntPtr jsContext);
		
		/// <summary>
        /// Begin opcode-level profiling of all JavaScript execution in the window's
        /// runtime.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StartPCCountProfiling(System.IntPtr jsContext);
		
		/// <summary>
        /// Stop opcode-level profiling of JavaScript execution in the runtime, and
        /// collect all counts for use by getPCCount methods.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopPCCountProfiling(System.IntPtr jsContext);
		
		/// <summary>
        /// Purge collected PC counters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PurgePCCounts(System.IntPtr jsContext);
		
		/// <summary>
        /// Get the number of scripts with opcode-level profiling information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetPCCountScriptCount(System.IntPtr jsContext);
		
		/// <summary>
        /// Get a JSON string for a short summary of a script and the PC counts
        /// accumulated for it.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPCCountScriptSummary(int script, System.IntPtr jsContext, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// Get a JSON string with full information about a profiled script,
        /// including the decompilation of the script and placement of decompiled
        /// operations within it, and PC counts for each operation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPCCountScriptContents(int script, System.IntPtr jsContext, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// Returns true if painting is suppressed for this window and false
        /// otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetPaintingSuppressedAttribute();
		
		/// <summary>
        /// Returns an array of plugins on the page for opt-in activation.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible).
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetPluginsAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// Set the scrollport size for the purposes of clamping scroll positions for
        /// the root scroll frame of this document to be (aWidth,aHeight) in CSS pixels.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetScrollPositionClampingScrollPortSize(float aWidth, float aHeight);
		
		/// <summary>
        /// Set margins for the layout of fixed position elements in the content
        /// document. These are used on mobile, where the viewable area can be
        /// temporarily obscured by the browser chrome. In this situation, we're ok
        /// with scrollable page content being obscured, but fixed position content
        /// cannot be revealed without removing the obscuring chrome, so we use these
        /// margins so that it can remain visible.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetContentDocumentFixedPositionMargins(float aTop, float aRight, float aBottom, float aLeft);
		
		/// <summary>
        /// These are used to control whether dialogs (alert, prompt, confirm) are
        /// allowed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DisableDialogs();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnableDialogs();
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool AreDialogsEnabled();
		
		/// <summary>
        /// Synchronously loads a style sheet from |sheetURI| and adds it to the list
        /// of additional style sheets of the document.
        ///
        /// These additional style sheets are very much like user/agent sheets loaded
        /// with loadAndRegisterSheet. The only difference is that they are applied only
        /// on the document owned by this window.
        ///
        /// Sheets added via this API take effect immediately on the document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadSheet([MarshalAs(UnmanagedType.Interface)] nsIURI sheetURI, uint type);
		
		/// <summary>
        /// Adds a style sheet to the list of additional style sheets of the document.
        ///
        /// Style sheets can be preloaded with nsIStyleSheetService.preloadSheet.
        ///
        /// Sheets added via this API take effect immediately on the document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddSheet([MarshalAs(UnmanagedType.Interface)] nsIDOMStyleSheet sheet, uint type);
		
		/// <summary>
        /// Remove the document style sheet at |sheetURI| from the list of additional
        /// style sheets of the document.  The removal takes effect immediately.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveSheet([MarshalAs(UnmanagedType.Interface)] nsIURI sheetURI, uint type);
		
		/// <summary>
        /// Returns true if a user input is being handled.
        ///
        /// This calls EventStateManager::IsHandlingUserInput().
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsHandlingUserInputAttribute();
		
		/// <summary>
        /// After calling the method, the window for which this DOMWindowUtils
        /// was created can be closed using scripts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AllowScriptsToClose();
		
		/// <summary>
        /// Is the parent window's main widget visible?  If it isn't, we probably
        /// don't want to display any dialogs etc it may request.  This corresponds
        /// to the visibility check in nsWindowWatcher::OpenWindowInternal().
        ///
        /// Will throw a DOM security error if called without chrome privileges or
        /// NS_ERROR_NOT_AVAILABLE in the unlikely event that the parent window's
        /// main widget can't be reached.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsParentWindowMainWidgetVisibleAttribute();
		
		/// <summary>
        /// In certain cases the event handling of nodes, form controls in practice,
        /// may be disabled. Such cases are for example the existence of disabled
        /// attribute or -moz-user-input: none/disabled.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsNodeDisabledForEvents([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aNode);
		
		/// <summary>
        /// Setting paintFlashing to true will flash newly painted area.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetPaintFlashingAttribute();
		
		/// <summary>
        /// Setting paintFlashing to true will flash newly painted area.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPaintFlashingAttribute([MarshalAs(UnmanagedType.U1)] bool aPaintFlashing);
		
		/// <summary>
        /// Allows running of a "synchronous section", in the form of an nsIRunnable
        /// once the event loop has reached a "stable state". We've reached a stable
        /// state when the currently executing task/event has finished, see:
        /// http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#synchronous-section
        /// In practice this runs aRunnable once the currently executing event
        /// finishes. If called multiple times per task/event, all the runnables will
        /// be executed, in the order in which runInStableState() was called.
        ///
        /// XXX - This can wreak havoc if you're not using this for very simple
        /// purposes, eg testing or setting a flag.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RunInStableState([MarshalAs(UnmanagedType.Interface)] nsIRunnable runnable);
		
		/// <summary>
        /// Run the given runnable before the next iteration of the event loop (this
        /// includes native events too). If a nested loop is spawned within the current
        /// event then the runnable will not be run until that loop has terminated.
        ///
        /// XXX - This can wreak havoc if you're not using this for very simple
        /// purposes, eg testing or setting a flag.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RunBeforeNextEvent([MarshalAs(UnmanagedType.Interface)] nsIRunnable runnable);
		
		/// <summary>
        /// Returns the value of a given property animated on the compositor thread.
        /// If the property is NOT currently being animated on the compositor thread,
        /// returns an empty string.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetOMTAStyle([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aProperty, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// If aHandlingInput is true, this informs the event state manager that
        /// we're handling user input. Otherwise, this is a no-op (as by default
        /// we're not handling user input).
        /// Remember to call destruct() on the return value!
        /// See also nsIDOMWindowUtils::isHandlingUserInput.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIJSRAIIHelper SetHandlingUserInput([MarshalAs(UnmanagedType.U1)] bool aHandlingInput);
		
		/// <summary>
        /// Get the content- and compositor-side APZ test data instances.
        /// The return values are of type APZTestData (see APZTestData.webidl).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetContentAPZTestData(System.IntPtr jsContext);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetCompositorAPZTestData(System.IntPtr jsContext);
		
		/// <summary>
        /// With this it's possible to mute all the MediaElements in this window.
        /// We have audioMuted and audioVolume to preserve the volume across
        /// mute/umute.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAudioMutedAttribute();
		
		/// <summary>
        /// With this it's possible to mute all the MediaElements in this window.
        /// We have audioMuted and audioVolume to preserve the volume across
        /// mute/umute.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAudioMutedAttribute([MarshalAs(UnmanagedType.U1)] bool aAudioMuted);
		
		/// <summary>
        /// range: greater or equal to 0. The real volume level is affected by the
        /// volume of all ancestor windows.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetAudioVolumeAttribute();
		
		/// <summary>
        /// range: greater or equal to 0. The real volume level is affected by the
        /// volume of all ancestor windows.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAudioVolumeAttribute(float aAudioVolume);
		
		/// <summary>
        /// This method doesn't do anything useful.  It was solely added for the
        /// purpose of the test for bug 503926.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void XpconnectArgument([MarshalAs(UnmanagedType.Interface)] nsIDOMWindowUtils aThis);
		
		/// <summary>
        /// Helper for JS components that need to send permission requests with
        /// e10s support properly.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AskPermission([MarshalAs(UnmanagedType.Interface)] nsIContentPermissionRequest aRequest);
	}
	
	/// <summary>nsIDOMWindowUtilsConsts </summary>
	public class nsIDOMWindowUtilsConsts
	{
		
		// <summary>
        // Following modifiers are for sent*Event() except sendNative*Event().
        // NOTE: MODIFIER_ALT, MODIFIER_CONTROL, MODIFIER_SHIFT and MODIFIER_META
        // are must be same values as nsIDOMNSEvent::*_MASK for backward
        // compatibility.
        // </summary>
		public const long MODIFIER_ALT = 0x0001;
		
		// 
		public const long MODIFIER_CONTROL = 0x0002;
		
		// 
		public const long MODIFIER_SHIFT = 0x0004;
		
		// 
		public const long MODIFIER_META = 0x0008;
		
		// 
		public const long MODIFIER_ALTGRAPH = 0x0010;
		
		// 
		public const long MODIFIER_CAPSLOCK = 0x0020;
		
		// 
		public const long MODIFIER_FN = 0x0040;
		
		// 
		public const long MODIFIER_NUMLOCK = 0x0080;
		
		// 
		public const long MODIFIER_SCROLLLOCK = 0x0100;
		
		// 
		public const long MODIFIER_SYMBOLLOCK = 0x0200;
		
		// 
		public const long MODIFIER_OS = 0x0400;
		
		// <summary>
        //Synthesize a wheel event for a window. The event types supported is only
        // wheel.
        //
        // Events are sent in coordinates offset by aX and aY from the window.
        //
        // Cannot be accessed from unprivileged context (not content-accessible)
        // Will throw a DOM security error if called without chrome privileges.
        //
        // @param aX                 x offset in CSS pixels
        // @param aY                 y offset in CSS pixels
        // @param aDeltaX            deltaX value.
        // @param aDeltaY            deltaY value.
        // @param aDeltaZ            deltaZ value.
        // @param aDeltaMode         deltaMode value which must be one of
        // nsIDOMWheelEvent::DOM_DELTA_*.
        // @param aModifiers         modifiers pressed, using constants defined as
        // MODIFIER_*
        // @param aLineOrPageDeltaX  If you set this value non-zero for
        // DOM_DELTA_PIXEL event, EventStateManager will
        // dispatch NS_MOUSE_SCROLL event for horizontal
        // scroll.
        // @param aLineOrPageDeltaY  If you set this value non-zero for
        // DOM_DELTA_PIXEL event, EventStateManager will
        // dispatch NS_MOUSE_SCROLL event for vertical
        // scroll.
        // @param aOptions           Set following flags.
        // </summary>
		public const ulong WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE = 0x0001;
		
		// <summary>
        // @deprecated Use WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE.
        // </summary>
		public const ulong WHEEL_EVENT_CAUSED_BY_PIXEL_ONLY_DEVICE = 0x0001;
		
		// 
		public const ulong WHEEL_EVENT_CAUSED_BY_MOMENTUM = 0x0002;
		
		// 
		public const ulong WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS = 0x0004;
		
		// <summary>
        // exception in case the relevant overflowDelta has an unexpected value.
        // </summary>
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO = 0x0010;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE = 0x0020;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE = 0x0040;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO = 0x0100;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE = 0x0200;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE = 0x0400;
		
		// <summary>
        // If this is set, preventDefault() the event before dispatch.
        // </summary>
		public const ulong KEY_FLAG_PREVENT_DEFAULT = 0x0001;
		
		// <summary>
        // on the key event. Otherwise it is true.
        // </summary>
		public const ulong KEY_FLAG_NOT_SYNTHESIZED_FOR_TESTS = 0x0002;
		
		// <summary>
        // Otherwise, it will be computed from aKeyCode.
        // </summary>
		public const ulong KEY_FLAG_LOCATION_STANDARD = 0x0010;
		
		// 
		public const ulong KEY_FLAG_LOCATION_LEFT = 0x0020;
		
		// 
		public const ulong KEY_FLAG_LOCATION_RIGHT = 0x0040;
		
		// 
		public const ulong KEY_FLAG_LOCATION_NUMPAD = 0x0080;
		
		// 
		public const ulong KEY_FLAG_LOCATION_MOBILE = 0x0100;
		
		// 
		public const ulong KEY_FLAG_LOCATION_JOYSTICK = 0x0200;
		
		// <summary>
        // If MOUSESCROLL_PREFER_WIDGET_AT_POINT is set, widget will dispatch
        // the event to a widget which is under the cursor.  Otherwise, dispatch to
        // a default target on the platform.  E.g., on Windows, it's focused window.
        // </summary>
		public const ulong MOUSESCROLL_PREFER_WIDGET_AT_POINT = 0x00000001;
		
		// <summary>
        // If MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL is set and aNativeMessage is
        // WM_VSCROLL or WM_HSCROLL, widget will set the window handle to the lParam
        // instead of NULL.
        // </summary>
		public const ulong MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL = 0x00010000;
		
		// <summary>
        // The pointer is in a hover state above the digitizer
        // </summary>
		public const long TOUCH_HOVER = 0x01;
		
		// <summary>
        // The pointer is in contact with the digitizer
        // </summary>
		public const long TOUCH_CONTACT = 0x02;
		
		// <summary>
        // The pointer has been removed from the digitizer detection area
        // </summary>
		public const long TOUCH_REMOVE = 0x04;
		
		// <summary>
        // that might get tirggered by input already delivered.
        // </summary>
		public const long TOUCH_CANCEL = 0x08;
		
		// <summary>
        // DISABLED means users cannot use IME completely.
        // Note that this state is *not* same as |ime-mode: disabled;|.
        // </summary>
		public const ulong IME_STATUS_DISABLED = 0;
		
		// <summary>
        // ENABLED means users can use all functions of IME. This state is same as
        // |ime-mode: normal;|.
        // </summary>
		public const ulong IME_STATUS_ENABLED = 1;
		
		// <summary>
        // PASSWORD means users cannot use most functions of IME. But on GTK2,
        // users can use "Simple IM" which only supports dead key inputting.
        // The behavior is same as the behavior of the native password field.
        // This state is same as |ime-mode: disabled;|.
        // </summary>
		public const ulong IME_STATUS_PASSWORD = 2;
		
		// <summary>
        // PLUGIN means a plug-in has focus. At this time we should not touch to
        // controlling the IME state.
        // </summary>
		public const ulong IME_STATUS_PLUGIN = 3;
		
		// <summary>
        // If sendQueryContentEvent()'s aAdditionalFlags argument is
        // QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK, plain text generated from content
        // is created with "\n".
        // Otherwise, platform dependent.  E.g., on Windows, "\r\n" is used.
        // aOffset and aLength are offset and length in/of the plain text content.
        // This flag also affects the result values such as offset, length and string.
        // </summary>
		public const ulong QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK = 0x0000;
		
		// 
		public const ulong QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK = 0x0001;
		
		// <summary>
        // QUERY_SELECTED_TEXT queries the first selection range's information.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return offset, reversed and text properties of the result are available.
        // </summary>
		public const ulong QUERY_SELECTED_TEXT = 3200;
		
		// <summary>
        // QUERY_TEXT_CONTENT queries the text at the specified range.
        //
        // @param aOffset   The first character's offset.  0 is the first character.
        // @param aLength   The length of getting text.  If the aLength is too long,
        // the result text is shorter than this value.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return text property of the result is available.
        // </summary>
		public const ulong QUERY_TEXT_CONTENT = 3201;
		
		// <summary>
        // QUERY_CARET_RECT queries the (collapsed) caret rect of the offset.
        // If the actual caret is there at the specified offset, this returns the
        // actual caret rect.  Otherwise, this guesses the caret rect from the
        // metrics of the text.
        //
        // @param aOffset   The caret offset.  0 is the left side of the first
        // caracter in LTR text.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // The left and the top properties are offset in the client area of
        // the DOM window.
        // </summary>
		public const ulong QUERY_CARET_RECT = 3203;
		
		// <summary>
        // QUERY_TEXT_RECT queries the specified text's rect.
        //
        // @param aOffset   The first character's offset.  0 is the first character.
        // @param aLength   The length of getting text.  If the aLength is too long,
        // the extra length is ignored.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // The left and the top properties are offset in the client area of
        // the DOM window.
        // </summary>
		public const ulong QUERY_TEXT_RECT = 3204;
		
		// <summary>
        // QUERY_TEXT_RECT queries the focused editor's rect.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // </summary>
		public const ulong QUERY_EDITOR_RECT = 3205;
		
		// <summary>
        // QUERY_CHARACTER_AT_POINT queries the character information at the
        // specified point.  The point is offset in the window.
        // NOTE: If there are some panels at the point, this method send the query
        // event to the panel's widget automatically.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        X offset in the widget.
        // @param aY        Y offset in the widget.
        //
        // @return offset, notFound, left, top, width and height properties of the
        // result are available.
        // </summary>
		public const ulong QUERY_CHARACTER_AT_POINT = 3208;
		
		// <summary>
        // If sendQueryContentEvent()'s aAdditionalFlags argument is
        // SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK, aOffset and aLength are offset
        // and length in/of plain text generated from content is created with "\n".
        // Otherwise, platform dependent.  E.g., on Windows, "\r\n" is used.
        // </summary>
		public const ulong SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK = 0x0000;
		
		// 
		public const ulong SELECTION_SET_FLAG_USE_XP_LINE_BREAK = 0x0001;
		
		// <summary>
        // If SELECTION_SET_FLAG_REVERSE is set, the selection is set from
        // |aOffset + aLength| to |aOffset|.  Otherwise, it's set from |aOffset| to
        // |aOffset + aLength|.
        // </summary>
		public const ulong SELECTION_SET_FLAG_REVERSE = 0x0002;
		
		// <summary>
        //Selection behaviors - mirror nsIFrame's nsSelectionAmount constants </summary>
		public const ulong SELECT_CHARACTER = 0;
		
		// 
		public const ulong SELECT_CLUSTER = 1;
		
		// 
		public const ulong SELECT_WORD = 2;
		
		// 
		public const ulong SELECT_LINE = 3;
		
		// 
		public const ulong SELECT_BEGINLINE = 4;
		
		// 
		public const ulong SELECT_ENDLINE = 5;
		
		// 
		public const ulong SELECT_PARAGRAPH = 6;
		
		// 
		public const ulong SELECT_WORDNOSPACE = 7;
		
		// 
		public const ulong AGENT_SHEET = 0;
		
		// 
		public const ulong USER_SHEET = 1;
		
		// 
		public const ulong AUTHOR_SHEET = 2;
	}
	
	/// <summary>nsITranslationNodeList </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("c694e359-7227-4392-a138-33c0cc1f15a6")]
	public interface nsITranslationNodeList
	{
		
		/// <summary>Member GetLengthAttribute </summary>
		/// <returns>A System.UInt32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLengthAttribute();
		
		/// <summary>Member Item </summary>
		/// <param name='index'> </param>
		/// <returns>A nsIDOMNode</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMNode Item(uint index);
		
		/// <summary>
        /// which its parent is not a translation node.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsTranslationRootAtIndex(uint index);
	}
	
	/// <summary>
    /// JS doesn't do RAII very well. We can use this interface to make remembering
    /// to destruct an object in a finally clause easier.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("52e5a996-d0a9-4efc-a6fa-24489c532b19")]
	public interface nsIJSRAIIHelper
	{
		
		/// <summary>
        /// JS doesn't do RAII very well. We can use this interface to make remembering
        /// to destruct an object in a finally clause easier.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Destruct();
	}
}
