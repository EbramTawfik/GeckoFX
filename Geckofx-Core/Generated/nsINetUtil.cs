// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsINetUtil.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// nsINetUtil provides various network-related utility methods.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ca68c485-9db3-4c12-82a6-4fab7948e2d5")]
	public interface nsINetUtil
	{
		
		/// <summary>
        /// Parse a content-type header and return the content type and
        /// charset (if any).
        ///
        /// @param aTypeHeader the header string to parse
        /// @param [out] aCharset the charset parameter specified in the
        /// header, if any.
        /// @param [out] aHadCharset whether a charset was explicitly specified.
        /// @return the MIME type specified in the header, in lower-case.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ParseContentType([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aTypeHeader, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aCharset, [MarshalAs(UnmanagedType.U1)] ref bool aHadCharset, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase retval);
		
		/// <summary>
        /// Test whether the given URI's handler has the given protocol flags.
        ///
        /// @param aURI the URI in question
        /// @param aFlags the flags we're testing for.
        ///
        /// @return whether the protocol handler for aURI has all the flags
        /// in aFlags.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ProtocolHasFlags([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, uint aFlag);
		
		/// <summary>
        /// Test whether the protocol handler for this URI or that for any of
        /// its inner URIs has the given protocol flags.  This will QI aURI to
        /// nsINestedURI and walk the nested URI chain.
        ///
        /// @param aURI the URI in question
        /// @param aFlags the flags we're testing for.
        ///
        /// @return whether any of the protocol handlers involved have all the flags
        /// in aFlags.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool URIChainHasFlags([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, uint aFlags);
		
		/// <summary>
        /// Take aURI and produce an immutable version of it for the caller.  If aURI
        /// is immutable this will be aURI itself; otherwise this will be a clone,
        /// marked immutable if possible.  Passing null to this method is allowed; in
        /// that case it will return null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIURI ToImmutableURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// Create a simple nested URI using the result of
        /// toImmutableURI on the passed-in aURI which may not be null.
        /// Note: The return URI will not have had its spec set yet.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIURI NewSimpleNestedURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// escape a string with %00-style escaping
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EscapeString([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aString, uint aEscapeType, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// %XX-Escape invalid chars in a URL segment.
        ///
        /// @param aStr the URL to be escaped
        /// @param aFlags the URL segment type flags
        ///
        /// @return the escaped string (the string itself if escaping did not happen)
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EscapeURL([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aStr, uint aFlags, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// Expands URL escape sequences
        ///
        /// @param aStr the URL to be unescaped
        /// @param aFlags only ESCAPE_URL_ONLY_NONASCII and ESCAPE_URL_SKIP_CONTROL
        /// are recognized.  If |aFlags| is 0 all escape sequences are
        /// unescaped
        /// @return unescaped string
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnescapeString([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aStr, uint aFlags, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// Extract the charset parameter location and value from a content-type
        /// header.
        ///
        /// @param aTypeHeader the header string to parse
        /// @param [out] aCharset the charset parameter specified in the
        /// header, if any.
        /// @param [out] aCharsetStart index of the start of the charset parameter
        /// (the ';' separating it from what came before) in aTypeHeader.
        /// If this function returns false, this argument will still be
        /// set, to the index of the location where a new charset should
        /// be inserted.
        /// @param [out] aCharsetEnd index of the end of the charset parameter (the
        /// ';' separating it from what comes after, or the end
        /// of the string) in aTypeHeader.  If this function returns
        /// false, this argument will still be set, to the index of the
        /// location where a new charset should be inserted.
        ///
        /// @return whether a charset parameter was found.  This can be false even in
        /// cases when parseContentType would claim to have a charset, if the type
        /// that won out does not have a charset parameter specified.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ExtractCharsetFromContentType([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aTypeHeader, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aCharset, ref int aCharsetStart, ref int aCharsetEnd);
	}
	
	/// <summary>nsINetUtilConsts </summary>
	public class nsINetUtilConsts
	{
		
		// <summary>
        //Escape every character with its %XX-escaped equivalent </summary>
		public const ulong ESCAPE_ALL = 0;
		
		// <summary>
        //Leave alphanumeric characters intact and %XX-escape all others </summary>
		public const ulong ESCAPE_XALPHAS = 1;
		
		// <summary>
        //Leave alphanumeric characters intact, convert spaces to '+',
        //      %XX-escape all others </summary>
		public const ulong ESCAPE_XPALPHAS = 2;
		
		// <summary>
        //Leave alphanumeric characters and forward slashes intact,
        //      %XX-escape all others </summary>
		public const ulong ESCAPE_URL_PATH = 4;
		
		// <summary>
        //%XX-escape URL scheme </summary>
		public const ulong ESCAPE_URL_SCHEME = 1;
		
		// <summary>
        //%XX-escape username in the URL </summary>
		public const ulong ESCAPE_URL_USERNAME = 1<<1;
		
		// <summary>
        //%XX-escape password in the URL </summary>
		public const ulong ESCAPE_URL_PASSWORD = 1<<2;
		
		// <summary>
        //%XX-escape URL host </summary>
		public const ulong ESCAPE_URL_HOST = 1<<3;
		
		// <summary>
        //%XX-escape URL directory </summary>
		public const ulong ESCAPE_URL_DIRECTORY = 1<<4;
		
		// <summary>
        //%XX-escape file basename in the URL </summary>
		public const ulong ESCAPE_URL_FILE_BASENAME = 1<<5;
		
		// <summary>
        //%XX-escape file extension in the URL </summary>
		public const ulong ESCAPE_URL_FILE_EXTENSION = 1<<6;
		
		// <summary>
        //%XX-escape URL parameters </summary>
		public const ulong ESCAPE_URL_PARAM = 1<<7;
		
		// <summary>
        //%XX-escape URL query </summary>
		public const ulong ESCAPE_URL_QUERY = 1<<8;
		
		// <summary>
        //%XX-escape URL ref </summary>
		public const ulong ESCAPE_URL_REF = 1<<9;
		
		// <summary>
        //%XX-escape URL path - same as escaping directory, basename and extension </summary>
		public const ulong ESCAPE_URL_FILEPATH = ESCAPE_URL_DIRECTORY|ESCAPE_URL_FILE_BASENAME|ESCAPE_URL_FILE_EXTENSION;
		
		// <summary>
        //%XX-escape scheme, username, password, host, path, params, query and ref </summary>
		public const ulong ESCAPE_URL_MINIMAL = ESCAPE_URL_SCHEME|ESCAPE_URL_USERNAME|ESCAPE_URL_PASSWORD|ESCAPE_URL_HOST|ESCAPE_URL_FILEPATH|ESCAPE_URL_PARAM|ESCAPE_URL_QUERY|ESCAPE_URL_REF;
		
		// <summary>
        //Force %XX-escaping of already escaped sequences </summary>
		public const ulong ESCAPE_URL_FORCED = 1<<10;
		
		// <summary>
        //Skip non-ascii octets, %XX-escape all others </summary>
		public const ulong ESCAPE_URL_ONLY_ASCII = 1<<11;
		
		// <summary>
        // Skip graphic octets (0x20-0x7E) when escaping
        // Skips all ASCII octets (0x00-0x7F) when unescaping
        // </summary>
		public const ulong ESCAPE_URL_ONLY_NONASCII = 1<<12;
		
		// <summary>
        //Force %XX-escape of colon </summary>
		public const ulong ESCAPE_URL_COLON = 1<<14;
		
		// <summary>
        //Skip C0 and DEL from unescaping </summary>
		public const ulong ESCAPE_URL_SKIP_CONTROL = 1<<15;
	}
}
