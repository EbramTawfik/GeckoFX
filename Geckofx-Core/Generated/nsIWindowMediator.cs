// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIWindowMediator.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    ///This Source Code Form is subject to the terms of the Mozilla Public
    /// License, v. 2.0. If a copy of the MPL was not distributed with this
    /// file, You can obtain one at http://mozilla.org/MPL/2.0/. </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("30cda5a1-a6df-4f32-9a73-0e59a32928c5")]
	public interface nsIWindowMediator
	{
		
		/// <summary>
        ///Return an enumerator which iterates over all windows of type aWindowType
        /// from the oldest window to the youngest.
        /// @param  aWindowType the returned enumerator will enumerate only
        /// windows of this type. ("type" is the
        /// |windowtype| attribute of the XML <window> element.)
        /// If null, all windows will be enumerated.
        /// @return an enumerator of nsIDOMWindows.  Note that windows close
        /// asynchronously in many cases, so windows returned from this
        /// enumerator can have .closed set to true.  Caveat enumerator!
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator GetEnumerator([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowType);
		
		/// <summary>
        ///Identical to getEnumerator except:
        /// @return an enumerator of nsIXULWindows
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator GetXULWindowEnumerator([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowType);
		
		/// <summary>
        ///Return an enumerator which iterates over all windows of type aWindowType
        /// in their z (front-to-back) order. Note this interface makes
        /// no requirement that a window couldn't be revisited if windows
        /// are re-ordered while z-order enumerators are active.
        /// @param  aWindowType the returned enumerator will enumerate only
        /// windows of this type. ("type" is the
        /// |windowtype| attribute of the XML <window> element.)
        /// If null, all windows will be enumerated.
        /// @param  aFrontToBack if true, the enumerator enumerates windows in order
        /// from front to back. back to front if false.
        /// @return an enumerator of nsIDOMWindows
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator GetZOrderDOMWindowEnumerator([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowType, [MarshalAs(UnmanagedType.U1)] bool aFrontToBack);
		
		/// <summary>
        ///Identical to getZOrderDOMWindowEnumerator except:
        /// @return an enumerator of nsIXULWindows
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator GetZOrderXULWindowEnumerator([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowType, [MarshalAs(UnmanagedType.U1)] bool aFrontToBack);
		
		/// <summary>
        ///This is a shortcut for simply fetching the first window in
        /// front to back order.
        /// @param  aWindowType return the topmost window of this type.
        /// ("type" is the |windowtype| attribute of
        /// the XML <window> element.)
        /// If null, return the topmost window of any type.
        /// @return the topmost window
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetMostRecentWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowType);
		
		/// <summary>
        /// Return the outer window with the given ID, if any.  Can return null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetOuterWindowWithId(ulong aOuterWindowID);
		
		/// <summary>
        /// Return the outer window with the given current window ID, if any.
        /// Can return null if no inner window with the ID exists or if it's not
        /// a current inner anymore.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetCurrentInnerWindowWithId(ulong aInnerWindowID);
		
		/// <summary>
        ///Add the window to the list of known windows. Listeners (see
        /// addListener) will be notified through their onOpenWindow method.
        /// @param aWindow the window to add
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterWindow([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow);
		
		/// <summary>
        ///Remove the window from the list of known windows. Listeners (see
        /// addListener) will be be notified through their onCloseWindow method.
        /// @param aWindow the window to remove
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnregisterWindow([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow);
		
		/// <summary>
        ///Call this method when a window gains focus. It's a primitive means of
        /// determining the most recent window. It's no longer necessary and it
        /// really should be removed.
        /// @param aWindow the window which has gained focus
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UpdateWindowTimeStamp([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow);
		
		/// <summary>
        ///Call this method when a window's title changes. Listeners (see
        /// addListener) will be notified through their onWindowTitleChange method.
        /// @param aWindow the window whose title has changed
        /// @param inTitle the window's new title
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UpdateWindowTitle([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string inTitle);
		
		/// <summary>
        ///A window wants to be moved in z-order. Calculate whether and how
        /// it should be constrained. Note this method is advisory only:
        /// it changes nothing either in WindowMediator's internal state
        /// or with the window.
        /// Note it compares the nsIXULWindow to nsIWidgets. A pure interface
        /// would use all nsIXULWindows. But we expect this to be called from
        /// callbacks originating in native window code. They are expected to
        /// hand us comparison values which are pulled from general storage
        /// in the native widget, and may not correspond to an nsIWidget at all.
        /// For that reason this interface requires only objects one step
        /// removed from the native window (nsIWidgets), and its implementation
        /// must be very understanding of what may be completely invalid
        /// pointers in those parameters.
        ///
        /// @param inWindow the window in question
        /// @param inPosition requested position
        /// values: zLevelTop: topmost window. zLevelBottom: bottom.
        /// zLevelBelow: below ioBelow. (the value of ioBelow will
        /// be ignored for zLevelTop and Bottom.)
        /// @param inBelow if inPosition==zLevelBelow, the window
        /// below which inWindow wants to be placed. Otherwise this
        /// variable is ignored.
        /// @param outPosition constrained position, values like inPosition.
        /// @param outBelow if outPosition==zLevelBelow, the window
        /// below which inWindow should be placed. Otherwise this
        /// this value will be null.
        /// @return PR_TRUE if the position returned is different from
        /// the position given.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool CalculateZPosition([MarshalAs(UnmanagedType.Interface)] nsIXULWindow inWindow, uint inPosition, System.IntPtr inBelow, ref uint outPosition, ref System.IntPtr outBelow);
		
		/// <summary>
        ///A window has been positioned behind another. Inform WindowMediator
        /// @param inWindow the window in question
        /// @param inPosition new position. values:
        /// zLevelTop: topmost window.
        /// zLevelBottom: bottom.
        /// zLevelBelow: below inBelow. (inBelow is ignored
        /// for other values of inPosition.)
        /// @param inBelow the window inWindow is behind, if zLevelBelow
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetZPosition([MarshalAs(UnmanagedType.Interface)] nsIXULWindow inWindow, uint inPosition, [MarshalAs(UnmanagedType.Interface)] nsIXULWindow inBelow);
		
		/// <summary>
        ///Return the window's Z level (as defined in nsIXULWindow).
        /// @param aWindow the window in question
        /// @return aWindow's z level
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetZLevel([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow);
		
		/// <summary>
        ///Set the window's Z level (as defined in nsIXULWindow). The implementation
        /// will reposition the window as necessary to match its new Z level.
        /// The implementation will assume a window's Z level to be
        /// nsIXULWindow::normalZ until it has been informed of a different level.
        /// @param aWindow the window in question
        /// @param aZLevel the window's new Z level
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetZLevel([MarshalAs(UnmanagedType.Interface)] nsIXULWindow aWindow, uint aZLevel);
		
		/// <summary>
        ///Register a listener for window status changes.
        /// keeps strong ref? (to be decided)
        /// @param aListener the listener to register
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddListener([MarshalAs(UnmanagedType.Interface)] nsIWindowMediatorListener aListener);
		
		/// <summary>
        ///Unregister a listener of window status changes.
        /// @param aListener the listener to unregister
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveListener([MarshalAs(UnmanagedType.Interface)] nsIWindowMediatorListener aListener);
	}
	
	/// <summary>nsIWindowMediatorConsts </summary>
	public class nsIWindowMediatorConsts
	{
		
		// <summary>
        //z-ordering: </summary>
		public const ulong zLevelTop = 1;
		
		// 
		public const ulong zLevelBottom = 2;
		
		// 
		public const ulong zLevelBelow = 3;
	}
}
