// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIMessageManager.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// Message managers provide a way for chrome-privileged JS code to
    /// communicate with each other, even across process boundaries.
    ///
    /// Message managers are separated into "parent side" and "child side".
    /// These don't always correspond to process boundaries, but can.  For
    /// each child-side message manager, there is always exactly one
    /// corresponding parent-side message manager that it sends messages
    /// to.  However, for each parent-side message manager, there may be
    /// either one or many child-side managers it can message.
    ///
    /// Message managers that always have exactly one "other side" are of
    /// type nsIMessageSender.  Parent-side message managers that have many
    /// "other sides" are of type nsIMessageBroadcaster.
    ///
    /// Child-side message managers can send synchronous messages to their
    /// parent side, but not the other way around.
    ///
    /// There are two realms of message manager hierarchies.  One realm
    /// approximately corresponds to DOM elements, the other corresponds to
    /// process boundaries.
    ///
    /// Message managers corresponding to DOM elements
    /// ==============================================
    ///
    /// In this realm of message managers, there are
    /// - "frame message managers" which correspond to frame elements
    /// - "window message managers" which correspond to top-level chrome
    /// windows
    /// - "group message managers" which correspond to named message
    /// managers with a specific window MM as the parent
    /// - the "global message manager", on the parent side.  See below.
    ///
    /// The DOM-realm message managers can communicate in the ways shown by
    /// the following diagram.  The parent side and child side can
    /// correspond to process boundaries, but don't always.
    ///
    /// Parent side                         Child side
    /// -------------                       ------------
    /// global MMg
    /// |
    /// +-->window MMw1
    /// |    |
    /// |    +-->frame MMp1_1<------------>frame MMc1_1
    /// |    |
    /// |    +-->frame MMp1_2<------------>frame MMc1_2
    /// |    |
    /// |    +-->group MMgr1
    /// |    |    |
    /// |    |    +-->frame MMp2_1<------->frame MMc2_1
    /// |    |    |
    /// |    |    +-->frame MMp2_2<------->frame MMc2_2
    /// |    |
    /// |    +-->group MMgr2
    /// |    |    ...
    /// |    |
    /// |    ...
    /// |
    /// +-->window MMw2
    /// ...
    ///
    /// For example: a message sent from MMc1_1, from the child side, is
    /// sent only to MMp1_1 on the parent side.  However, note that all
    /// message managers in the hierarchy above MMp1_1, in this diagram
    /// MMw1 and MMg, will also notify their message listeners when the
    /// message arrives.
    ///
    /// A message sent from MMc2_1 will be sent to MMp2_1 and also notify
    /// all message managers in the hierarchy above that, including the
    /// group message manager MMgr1.
    /// For example: a message broadcast through the global MMg on the
    /// parent side would be broadcast to MMw1, which would transitively
    /// broadcast it to MMp1_1, MM1p_2.  The message would next be
    /// broadcast to MMgr1, which would broadcast it to MMp2_1 and MMp2_2.
    /// After that it would broadcast to MMgr2 and then to MMw2, and so
    /// on down the hierarchy.
    ///
    /// ***** PERFORMANCE AND SECURITY WARNING *****
    /// Messages broadcast through the global MM and window or group MMs
    /// can result in messages being dispatched across many OS processes,
    /// and to many processes with different permissions.  Great care
    /// should be taken when broadcasting.
    ///
    /// Interfaces
    /// ----------
    ///
    /// The global MMg and window MMw's are message broadcasters implementing
    /// nsIMessageBroadcaster while the frame MMp's are simple message senders
    /// (nsIMessageSender). Their counterparts in the content processes are
    /// message senders implementing nsIContentFrameMessageManager.
    ///
    /// nsIMessageListenerManager
    /// /                           \
    /// nsIMessageSender                               nsIMessageBroadcaster
    /// |
    /// nsISyncMessageSender (content process/in-process only)
    /// |
    /// nsIContentFrameMessageManager (content process/in-process only)
    /// |
    /// nsIInProcessContentFrameMessageManager (in-process only)
    ///
    ///
    /// Message managers in the chrome process can also be QI'ed to nsIFrameScriptLoader.
    ///
    ///
    /// Message managers corresponding to process boundaries
    /// ====================================================
    ///
    /// The second realm of message managers is the "process message
    /// managers".  With one exception, these always correspond to process
    /// boundaries.  The picture looks like
    ///
    /// Parent process                      Child processes
    /// ----------------                    -----------------
    /// global (GPPMM)
    /// |
    /// +-->parent in-process PIPMM<-->child in-process CIPPMM
    /// |
    /// +-->parent (PPMM1)<------------------>child (CPMM1)
    /// |
    /// +-->parent (PPMM2)<------------------>child (CPMM2)
    /// ...
    ///
    /// Note, PIPMM and CIPPMM both run in the parent process.
    ///
    /// For example: the parent-process PPMM1 sends messages to the
    /// child-process CPMM1.
    ///
    /// For example: CPMM1 sends messages directly to PPMM1. The global GPPMM
    /// will also notify their message listeners when the message arrives.
    ///
    /// For example: messages sent through the global GPPMM will be
    /// dispatched to the listeners of the same-process, CIPPMM, CPMM1,
    /// CPMM2, etc.
    ///
    /// ***** PERFORMANCE AND SECURITY WARNING *****
    /// Messages broadcast through the GPPMM can result in messages
    /// being dispatched across many OS processes, and to many processes
    /// with different permissions.  Great care should be taken when
    /// broadcasting.
    ///
    /// Requests sent to parent-process message listeners should usually
    /// have replies scoped to the requesting CPMM.  The following pattern
    /// is common
    ///
    /// const ParentProcessListener = {
    /// receiveMessage: function(aMessage) {
    /// let childMM = aMessage.target.QueryInterface(Ci.nsIMessageSender);
    /// switch (aMessage.name) {
    /// case "Foo:Request":
    /// // service request
    /// childMM.sendAsyncMessage("Foo:Response", { data });
    /// }
    /// }
    /// };
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2b44eb57-a9c6-4773-9a1e-fe0818739a4c")]
	public interface nsIMessageListener
	{
		
		/// <summary>
        /// This is for JS only.
        /// receiveMessage is called with one parameter, which has the following
        /// properties:
        /// {
        /// target:    %the target of the message. Either an element owning
        /// the message manager, or message manager itself if no
        /// element owns it%
        /// name:      %message name%,
        /// sync:      %true or false%.
        /// data:      %structured clone of the sent message data%,
        /// json:      %same as .data, deprecated%,
        /// objects:   %named table of jsvals/objects, or null%
        /// principal: %principal for the window app
        /// }
        ///
        /// Each listener is invoked with its own copy of the message
        /// parameter.
        ///
        /// When the listener is called, 'this' value is the target of the message.
        ///
        /// If the message is synchronous, the possible return value is
        /// returned as JSON (will be changed to use structured clones).
        /// When there are multiple listeners to sync messages, each
        /// listener's return value is sent back as an array.  |undefined|
        /// return values show up as undefined values in the array.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReceiveMessage();
	}
	
	/// <summary>nsIMessageListenerManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("b949bfec-bb7d-47bc-b387-ac6a9b655072")]
	public interface nsIMessageListenerManager
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool MarkForCC();
	}
	
	/// <summary>
    /// Message "senders" have a single "other side" to which messages are
    /// sent.  For example, a child-process message manager will send
    /// messages that are only delivered to its one parent-process message
    /// manager.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("bb5d79e4-e73c-45e7-9651-4d718f4b994c")]
	public interface nsIMessageSender : nsIMessageListenerManager
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
	}
	
	/// <summary>
    /// Message "broadcasters" don't have a single "other side" that they
    /// send messages to, but rather a set of subordinate message managers.
    /// For example, broadcasting a message through a window message
    /// manager will broadcast the message to all frame message managers
    /// within its window.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("4d7d62ad-4725-4f39-86cf-8fb22bf9c1d8")]
	public interface nsIMessageBroadcaster : nsIMessageListenerManager
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Like |sendAsyncMessage()|, but also broadcasts this message to
        /// all "child" message managers of this message manager.  See long
        /// comment above for details.
        ///
        /// WARNING: broadcasting messages can be very expensive and leak
        /// sensitive data.  Use with extreme caution.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BroadcastAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Number of subordinate message managers.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetChildCountAttribute();
		
		/// <summary>
        /// Return a single subordinate message manager.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIMessageListenerManager GetChildAt(uint aIndex);
	}
	
	/// <summary>nsISyncMessageSender </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("0e602c9e-1977-422a-a8e4-fe0d4a4f78d0")]
	public interface nsISyncMessageSender : nsIMessageSender
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendAsyncMessage()|, except blocks the sender until all
        /// listeners of the message have been invoked.  Returns an array
        /// containing return values from each listener invoked.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SendSyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendSyncMessage()|, except re-entrant. New RPC messages may be
        /// issued even if, earlier on the call stack, we are waiting for a reply
        /// to an earlier sendRpcMessage() call.
        ///
        /// Both sendSyncMessage and sendRpcMessage will block until a reply is
        /// received, but they may be temporarily interrupted to process an urgent
        /// incoming message (such as a CPOW request).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SendRpcMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
	}
	
	/// <summary>nsIMessageManagerGlobal </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("13f3555f-769e-44ea-b607-5239230c3162")]
	public interface nsIMessageManagerGlobal : nsISyncMessageSender
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendAsyncMessage()|, except blocks the sender until all
        /// listeners of the message have been invoked.  Returns an array
        /// containing return values from each listener invoked.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendSyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendSyncMessage()|, except re-entrant. New RPC messages may be
        /// issued even if, earlier on the call stack, we are waiting for a reply
        /// to an earlier sendRpcMessage() call.
        ///
        /// Both sendSyncMessage and sendRpcMessage will block until a reply is
        /// received, but they may be temporarily interrupted to process an urgent
        /// incoming message (such as a CPOW request).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendRpcMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Print a string to stdout.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Dump([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aStr);
		
		/// <summary>
        /// If leak detection is enabled, print a note to the leak log that this
        /// process will intentionally crash.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PrivateNoteIntentionalCrash();
		
		/// <summary>
        /// Ascii base64 data to binary data and vice versa
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Atob([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aAsciiString, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>Member Btoa </summary>
		/// <param name='aBase64Data'> </param>
		/// <param name='retval'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Btoa([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aBase64Data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
	}
	
	/// <summary>nsIContentFrameMessageManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("fff36099-9f84-4c7c-b69a-1cbf103d1708")]
	public interface nsIContentFrameMessageManager : nsIMessageManagerGlobal
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendAsyncMessage()|, except blocks the sender until all
        /// listeners of the message have been invoked.  Returns an array
        /// containing return values from each listener invoked.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendSyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendSyncMessage()|, except re-entrant. New RPC messages may be
        /// issued even if, earlier on the call stack, we are waiting for a reply
        /// to an earlier sendRpcMessage() call.
        ///
        /// Both sendSyncMessage and sendRpcMessage will block until a reply is
        /// received, but they may be temporarily interrupted to process an urgent
        /// incoming message (such as a CPOW request).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendRpcMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Print a string to stdout.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Dump([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aStr);
		
		/// <summary>
        /// If leak detection is enabled, print a note to the leak log that this
        /// process will intentionally crash.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PrivateNoteIntentionalCrash();
		
		/// <summary>
        /// Ascii base64 data to binary data and vice versa
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Atob([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aAsciiString, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>Member Btoa </summary>
		/// <param name='aBase64Data'> </param>
		/// <param name='retval'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Btoa([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aBase64Data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// The current top level window in the frame or null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetContentAttribute();
		
		/// <summary>
        /// The top level docshell or null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDocShell GetDocShellAttribute();
	}
	
	/// <summary>nsIInProcessContentFrameMessageManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9c6bd4d7-88d2-46d6-8606-f2d57d46f051")]
	public interface nsIInProcessContentFrameMessageManager : nsIContentFrameMessageManager
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendAsyncMessage()|, except blocks the sender until all
        /// listeners of the message have been invoked.  Returns an array
        /// containing return values from each listener invoked.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendSyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendSyncMessage()|, except re-entrant. New RPC messages may be
        /// issued even if, earlier on the call stack, we are waiting for a reply
        /// to an earlier sendRpcMessage() call.
        ///
        /// Both sendSyncMessage and sendRpcMessage will block until a reply is
        /// received, but they may be temporarily interrupted to process an urgent
        /// incoming message (such as a CPOW request).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendRpcMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Print a string to stdout.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Dump([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aStr);
		
		/// <summary>
        /// If leak detection is enabled, print a note to the leak log that this
        /// process will intentionally crash.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PrivateNoteIntentionalCrash();
		
		/// <summary>
        /// Ascii base64 data to binary data and vice versa
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Atob([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aAsciiString, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>Member Btoa </summary>
		/// <param name='aBase64Data'> </param>
		/// <param name='retval'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Btoa([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aBase64Data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// The current top level window in the frame or null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMWindow GetContentAttribute();
		
		/// <summary>
        /// The top level docshell or null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShell GetDocShellAttribute();
		
		/// <summary>Member GetOwnerContent </summary>
		/// <returns>A System.IntPtr</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetOwnerContent();
		
		/// <summary>Member CacheFrameLoader </summary>
		/// <param name='aFrameLoader'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CacheFrameLoader(System.IntPtr aFrameLoader);
	}
	
	/// <summary>nsIContentProcessMessageManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("6d12e467-2446-46db-9965-e4e93cb87ca5")]
	public interface nsIContentProcessMessageManager : nsIMessageManagerGlobal
	{
		
		/// <summary>
        /// Register |listener| to receive |messageName|.  All listener
        /// callbacks for a particular message are invoked when that message
        /// is received.
        ///
        /// The message manager holds a strong ref to |listener|.
        ///
        /// If the same listener registers twice for the same message, the
        /// second registration is ignored.
        ///
        /// Pass true for listenWhenClosed if you want to receive messages
        /// during the short period after a frame has been removed from the
        /// DOM and before its frame script has finished unloading. This
        /// parameter only has an effect for frame message managers in
        /// the main process. Default is false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener, [MarshalAs(UnmanagedType.U1)] bool listenWhenClosed);
		
		/// <summary>
        /// Undo an |addMessageListener| call -- that is, calling this causes us to no
        /// longer invoke |listener| when |messageName| is received.
        ///
        /// removeMessageListener does not remove a message listener added via
        /// addWeakMessageListener; use removeWeakMessageListener for that.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This is just like addMessageListener, except the message manager holds a
        /// weak ref to |listener|.
        ///
        /// If you have two weak message listeners for the same message, they may be
        /// called in any order.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>
        /// This undoes an |addWeakMessageListener| call.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveWeakMessageListener([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, [MarshalAs(UnmanagedType.Interface)] nsIMessageListener listener);
		
		/// <summary>Member MarkForCC </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool MarkForCC();
		
		/// <summary>
        /// Send |messageName| and |obj| to the "other side" of this message
        /// manager.  This invokes listeners who registered for
        /// |messageName|.
        ///
        /// See nsIMessageListener::receiveMessage() for the format of the
        /// data delivered to listeners.
        /// @throws NS_ERROR_NOT_INITIALIZED if the sender is not initialized.  For
        /// example, we will throw NS_ERROR_NOT_INITIALIZED if we try to send
        /// a message to a cross-process frame but the other process has not
        /// yet been set up.
        /// @throws NS_ERROR_FAILURE when the message receiver cannot be found.  For
        /// example, we will throw NS_ERROR_FAILURE if we try to send a message
        /// to a cross-process frame whose process has crashed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SendAsyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendAsyncMessage()|, except blocks the sender until all
        /// listeners of the message have been invoked.  Returns an array
        /// containing return values from each listener invoked.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendSyncMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Like |sendSyncMessage()|, except re-entrant. New RPC messages may be
        /// issued even if, earlier on the call stack, we are waiting for a reply
        /// to an earlier sendRpcMessage() call.
        ///
        /// Both sendSyncMessage and sendRpcMessage will block until a reply is
        /// received, but they may be temporarily interrupted to process an urgent
        /// incoming message (such as a CPOW request).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal SendRpcMessage([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase messageName, ref Gecko.JsVal obj, ref Gecko.JsVal objects, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Print a string to stdout.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Dump([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aStr);
		
		/// <summary>
        /// If leak detection is enabled, print a note to the leak log that this
        /// process will intentionally crash.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PrivateNoteIntentionalCrash();
		
		/// <summary>
        /// Ascii base64 data to binary data and vice versa
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Atob([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aAsciiString, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>Member Btoa </summary>
		/// <param name='aBase64Data'> </param>
		/// <param name='retval'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Btoa([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aBase64Data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase retval);
		
		/// <summary>
        /// Read out a copy of the object that was initialized in the parent
        /// process via nsIProcessScriptLoader.initialProcessData.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetInitialProcessDataAttribute(System.IntPtr jsContext);
	}
	
	/// <summary>nsIFrameScriptLoader </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("bf61446b-ba24-4b1d-88c7-4f94724b9ce1")]
	public interface nsIFrameScriptLoader
	{
		
		/// <summary>
        /// Load a script in the (remote) frame. aURL must be the absolute URL.
        /// data: URLs are also supported. For example data:,dump("foo\n");
        /// If aAllowDelayedLoad is true, script will be loaded when the
        /// remote frame becomes available. Otherwise the script will be loaded
        /// only if the frame is already available.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadFrameScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL, [MarshalAs(UnmanagedType.U1)] bool aAllowDelayedLoad, [MarshalAs(UnmanagedType.U1)] bool aRunInGlobalScope);
		
		/// <summary>
        /// Removes aURL from the list of scripts which support delayed load.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveDelayedFrameScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL);
		
		/// <summary>
        /// Returns all delayed scripts that will be loaded once a (remote)
        /// frame becomes available. The return value is a list of pairs
        /// [<URL>, <WasLoadedInGlobalScope>].
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetDelayedFrameScripts(System.IntPtr jsContext);
	}
	
	/// <summary>nsIProcessScriptLoader </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("7e1e1a20-b24f-11e4-ab27-0800200c9a66")]
	public interface nsIProcessScriptLoader
	{
		
		/// <summary>
        /// Load a script in the (possibly remote) process. aURL must be the absolute URL.
        /// data: URLs are also supported. For example data:,dump("foo\n");
        /// If aAllowDelayedLoad is true, script will be loaded when the
        /// remote frame becomes available. Otherwise the script will be loaded
        /// only if the frame is already available.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadProcessScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL, [MarshalAs(UnmanagedType.U1)] bool aAllowDelayedLoad);
		
		/// <summary>
        /// Removes aURL from the list of scripts which support delayed load.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveDelayedProcessScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL);
		
		/// <summary>
        /// Returns all delayed scripts that will be loaded once a (remote)
        /// frame becomes available. The return value is a list of URLs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetDelayedProcessScripts(System.IntPtr jsContext);
	}
	
	/// <summary>nsIGlobalProcessScriptLoader </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("5b390753-abb3-49b0-ae3b-b803dab58144")]
	public interface nsIGlobalProcessScriptLoader : nsIProcessScriptLoader
	{
		
		/// <summary>
        /// Load a script in the (possibly remote) process. aURL must be the absolute URL.
        /// data: URLs are also supported. For example data:,dump("foo\n");
        /// If aAllowDelayedLoad is true, script will be loaded when the
        /// remote frame becomes available. Otherwise the script will be loaded
        /// only if the frame is already available.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LoadProcessScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL, [MarshalAs(UnmanagedType.U1)] bool aAllowDelayedLoad);
		
		/// <summary>
        /// Removes aURL from the list of scripts which support delayed load.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveDelayedProcessScript([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aURL);
		
		/// <summary>
        /// Returns all delayed scripts that will be loaded once a (remote)
        /// frame becomes available. The return value is a list of URLs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new Gecko.JsVal GetDelayedProcessScripts(System.IntPtr jsContext);
		
		/// <summary>
        /// Allows the parent process to set the initial process data for
        /// new, not-yet-created child processes. This attribute should only
        /// be used by the global parent process message manager. When a new
        /// process is created, it gets a copy of this data (via structured
        /// cloning). It can access the data via the initialProcessData
        /// attribute of its childprocessmessagemanager.
        ///
        /// This value will always be a JS object. Different users are
        /// expected to set properties on this object. The property name
        /// should be unique enough that other Gecko consumers won't
        /// accidentally choose it.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetInitialProcessDataAttribute(System.IntPtr jsContext);
	}
	
	/// <summary>nsIProcessChecker </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("637e8538-4f8f-4a3d-8510-e74386233e19")]
	public interface nsIProcessChecker
	{
		
		/// <summary>Member KillChild </summary>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool KillChild();
		
		/// <summary>
        /// Return true if the "remote" process has |aPermission|.  This is
        /// intended to be used by JS implementations of cross-process DOM
        /// APIs, like so
        ///
        /// recvFooRequest: function(message) {
        /// if (!message.target.assertPermission("foo")) {
        /// return false;
        /// }
        /// // service foo request
        ///
        /// This interface only returns meaningful data when our content is
        /// in a separate process.  If it shares the same OS process as us,
        /// then applying this permission check doesn't add any security,
        /// though it doesn't hurt anything either.
        ///
        /// Note: If the remote content process does *not* have |aPermission|,
        /// it will be killed as a precaution.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool AssertPermission([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aPermission);
		
		/// <summary>
        /// Return true if the "remote" process has |aManifestURL|.  This is
        /// intended to be used by JS implementations of cross-process DOM
        /// APIs, like so
        ///
        /// recvFooRequest: function(message) {
        /// if (!message.target.assertContainApp("foo")) {
        /// return false;
        /// }
        /// // service foo request
        ///
        /// This interface only returns meaningful data when our content is
        /// in a separate process.  If it shares the same OS process as us,
        /// then applying this manifest URL check doesn't add any security,
        /// though it doesn't hurt anything either.
        ///
        /// Note: If the remote content process does *not* contain |aManifestURL|,
        /// it will be killed as a precaution.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool AssertContainApp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aManifestURL);
		
		/// <summary>Member AssertAppHasPermission </summary>
		/// <param name='aPermission'> </param>
		/// <returns>A System.Boolean</returns>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool AssertAppHasPermission([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aPermission);
		
		/// <summary>
        /// Return true if the "remote" process' principal has an appStatus equal to
        /// |aStatus|.
        ///
        /// This interface only returns meaningful data when our content is
        /// in a separate process.  If it shares the same OS process as us,
        /// then applying this permission check doesn't add any security,
        /// though it doesn't hurt anything either.
        ///
        /// Note: If the remote content process does *not* has the |aStatus|,
        /// it will be killed as a precaution.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool AssertAppHasStatus(ushort aStatus);
	}
}
