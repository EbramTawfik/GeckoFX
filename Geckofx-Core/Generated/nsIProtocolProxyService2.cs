// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIProtocolProxyService2.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// An extension of nsIProtocolProxyService
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("b2e5b2c0-e21e-4845-b336-be6d60a38951")]
	public interface nsIProtocolProxyService2 : nsIProtocolProxyService
	{
		
		/// <summary>
        /// This method returns via callback a nsIProxyInfo instance that identifies
        /// a proxy to be used for the given channel.  Otherwise, this method returns
        /// null indicating that a direct connection should be used.
        ///
        /// @param aChannelOrURI
        /// The channel for which a proxy is to be found, or, if no channel is
        /// available, a URI indicating the same. This method will return
        /// NS_ERROR_NOINTERFACE if this argument isn't either an nsIURI or an
        /// nsIChannel.
        /// @param aFlags
        /// A bit-wise combination of the RESOLVE_ flags defined above.  Pass
        /// 0 to specify the default behavior.  Any additional bits that do
        /// not correspond to a RESOLVE_ flag are reserved for future use.
        /// @param aCallback
        /// The object to be notified when the result is available.
        ///
        /// @return An object that can be used to cancel the asychronous operation.
        /// If canceled, the cancelation status (aReason) will be forwarded
        /// to the callback's onProxyAvailable method via the aStatus param.
        ///
        /// NOTE: If this proxy is unavailable, getFailoverForProxy may be called
        /// to determine the correct secondary proxy to be used.
        ///
        /// NOTE: If the protocol handler for the given URI supports
        /// nsIProxiedProtocolHandler, then the nsIProxyInfo instance returned from
        /// resolve may be passed to the newProxiedChannel method to create a
        /// nsIChannel to the given URI that uses the specified proxy.
        ///
        /// NOTE: However, if the nsIProxyInfo type is "http", then it means that
        /// the given URI should be loaded using the HTTP protocol handler, which
        /// also supports nsIProxiedProtocolHandler.
        ///
        /// @see nsIProxiedProtocolHandler::newProxiedChannel
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsICancelable AsyncResolve([MarshalAs(UnmanagedType.Interface)] nsISupports aChannelOrURI, uint aFlags, [MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyCallback aCallback);
		
		/// <summary>
        /// This method may be called to construct a nsIProxyInfo instance from
        /// the given parameters.  This method may be useful in conjunction with
        /// nsISocketTransportService::createTransport for creating, for example,
        /// a SOCKS connection.
        ///
        /// @param aType
        /// The proxy type.  This is a string value that identifies the proxy
        /// type.  Standard values include:
        /// "http"    - specifies a HTTP proxy
        /// "https"   - specifies HTTP proxying over TLS connection to proxy
        /// "socks"   - specifies a SOCKS version 5 proxy
        /// "socks4"  - specifies a SOCKS version 4 proxy
        /// "direct"  - specifies a direct connection (useful for failover)
        /// The type name is case-insensitive.  Other string values may be
        /// possible, and new types may be defined by a future version of
        /// this interface.
        /// @param aHost
        /// The proxy hostname or IP address.
        /// @param aPort
        /// The proxy port.
        /// @param aFlags
        /// Flags associated with this connection.  See nsIProxyInfo.idl
        /// for currently defined flags.
        /// @param aFailoverTimeout
        /// Specifies the length of time (in seconds) to ignore this proxy if
        /// this proxy fails.  Pass UINT32_MAX to specify the default
        /// timeout value, causing nsIProxyInfo::failoverTimeout to be
        /// assigned the default value.
        /// @param aFailoverProxy
        /// Specifies the next proxy to try if this proxy fails.  This
        /// parameter may be null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIProxyInfo NewProxyInfo([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aType, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aHost, int aPort, uint aFlags, uint aFailoverTimeout, [MarshalAs(UnmanagedType.Interface)] nsIProxyInfo aFailoverProxy);
		
		/// <summary>
        /// This method may be called to construct a nsIProxyInfo instance for
        /// with the specified username and password.
        /// Currently implemented for SOCKS proxies only.
        /// @param aType
        /// The proxy type.  This is a string value that identifies the proxy
        /// type.  Standard values include:
        /// "socks"   - specifies a SOCKS version 5 proxy
        /// "socks4"  - specifies a SOCKS version 4 proxy
        /// The type name is case-insensitive.  Other string values may be
        /// possible, and new types may be defined by a future version of
        /// this interface.
        /// @param aHost
        /// The proxy hostname or IP address.
        /// @param aPort
        /// The proxy port.
        /// @param aUsername
        /// The proxy username
        /// @param aPassword
        /// The proxy password
        /// @param aFlags
        /// Flags associated with this connection.  See nsIProxyInfo.idl
        /// for currently defined flags.
        /// @param aFailoverTimeout
        /// Specifies the length of time (in seconds) to ignore this proxy if
        /// this proxy fails.  Pass UINT32_MAX to specify the default
        /// timeout value, causing nsIProxyInfo::failoverTimeout to be
        /// assigned the default value.
        /// @param aFailoverProxy
        /// Specifies the next proxy to try if this proxy fails.  This
        /// parameter may be null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIProxyInfo NewProxyInfoWithAuth([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aType, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aHost, int aPort, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aUsername, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aPassword, uint aFlags, uint aFailoverTimeout, [MarshalAs(UnmanagedType.Interface)] nsIProxyInfo aFailoverProxy);
		
		/// <summary>
        /// If the proxy identified by aProxyInfo is unavailable for some reason,
        /// this method may be called to access an alternate proxy that may be used
        /// instead.  As a side-effect, this method may affect future result values
        /// from resolve/asyncResolve as well as from getFailoverForProxy.
        ///
        /// @param aProxyInfo
        /// The proxy that was unavailable.
        /// @param aURI
        /// The URI that was originally passed to resolve/asyncResolve.
        /// @param aReason
        /// The error code corresponding to the proxy failure.  This value
        /// may be used to tune the delay before this proxy is used again.
        ///
        /// @throw NS_ERROR_NOT_AVAILABLE if there is no alternate proxy available.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIProxyInfo GetFailoverForProxy([MarshalAs(UnmanagedType.Interface)] nsIProxyInfo aProxyInfo, [MarshalAs(UnmanagedType.Interface)] nsIURI aURI, int aReason);
		
		/// <summary>
        /// This method may be used to register a proxy filter instance.  Each proxy
        /// filter is registered with an associated position that determines the
        /// order in which the filters are applied (starting from position 0).  When
        /// resolve/asyncResolve is called, it generates a list of proxies for the
        /// given URI, and then it applies the proxy filters.  The filters have the
        /// opportunity to modify the list of proxies.
        ///
        /// If two filters register for the same position, then the filters will be
        /// visited in the order in which they were registered.
        ///
        /// If the filter is already registered, then its position will be updated.
        ///
        /// After filters have been run, any disabled or disallowed proxies will be
        /// removed from the list.  A proxy is disabled if it had previously failed-
        /// over to another proxy (see getFailoverForProxy).  A proxy is disallowed,
        /// for example, if it is a HTTP proxy and the nsIProtocolHandler for the
        /// queried URI does not permit proxying via HTTP.
        ///
        /// If a nsIProtocolHandler disallows all proxying, then filters will never
        /// have a chance to intercept proxy requests for such URLs.
        ///
        /// @param aFilter
        /// The nsIProtocolProxyFilter instance to be registered.
        /// @param aPosition
        /// The position of the filter.
        ///
        /// NOTE: It is possible to construct filters that compete with one another
        /// in undesirable ways.  This API does not attempt to protect against such
        /// problems.  It is recommended that any extensions that choose to call
        /// this method make their position value configurable at runtime (perhaps
        /// via the preferences service).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RegisterFilter([MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyFilter aFilter, uint aPosition);
		
		/// <summary>
        /// Similar to registerFilter, but accepts an nsIProtocolProxyChannelFilter,
        /// which selects proxies according to channel rather than URI.
        ///
        /// @param aFilter
        /// The nsIProtocolProxyChannelFilter instance to be registered.
        /// @param aPosition
        /// The position of the filter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RegisterChannelFilter([MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyChannelFilter aFilter, uint aPosition);
		
		/// <summary>
        /// This method may be used to unregister a proxy filter instance.  All
        /// filters will be automatically unregistered at XPCOM shutdown.
        ///
        /// @param aFilter
        /// The nsIProtocolProxyFilter instance to be unregistered.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void UnregisterFilter([MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyFilter aFilter);
		
		/// <summary>
        /// This method may be used to unregister a proxy channel filter instance.  All
        /// filters will be automatically unregistered at XPCOM shutdown.
        ///
        /// @param aFilter
        /// The nsIProtocolProxyChannelFilter instance to be unregistered.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void UnregisterChannelFilter([MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyChannelFilter aFilter);
		
		/// <summary>
        /// This attribute specifies the current type of proxy configuration.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new uint GetProxyConfigTypeAttribute();
		
		/// <summary>
        /// Call this method to cause the PAC file (if any is configured) to be
        /// reloaded.  The PAC file is loaded asynchronously.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReloadPAC();
		
		/// <summary>
        /// This method is identical to asyncResolve() except:
        /// - it only accepts an nsIChannel, not an nsIURI;
        /// - it may execute the callback function immediately (i.e from the stack
        /// of asyncResolve2()) if it is immediately ready to run.
        /// The nsICancelable return value will be null in that case.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICancelable AsyncResolve2([MarshalAs(UnmanagedType.Interface)] nsIChannel aChannel, uint aFlags, [MarshalAs(UnmanagedType.Interface)] nsIProtocolProxyCallback aCallback);
	}
}
