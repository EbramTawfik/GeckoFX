// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsITimer.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// The callback interface for timers.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("a796816d-7d47-4348-9ab8-c7aeb3216a7d")]
	public interface nsITimerCallback
	{
		
		/// <summary>
        /// @param aTimer the timer which has expired
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Notify([MarshalAs(UnmanagedType.Interface)] nsITimer timer);
	}
	
	/// <summary>
    /// nsITimer instances must be initialized by calling one of the "init" methods
    /// documented below.  You may also re-initialize (using one of the init()
    /// methods) an existing instance to avoid the overhead of destroying and
    /// creating a timer.  It is not necessary to cancel the timer in that case.
    ///
    /// By default a timer will fire on the thread that created it.  Set the .target
    /// attribute to fire on a different thread.  Once you have set a timer's .target
    /// and called one of its init functions, any further interactions with the timer
    /// (calling cancel(), changing member fields, etc) should only be done by the
    /// target thread, or races may occur with bad results like timers firing after
    /// they've been canceled, and/or not firing after re-initiatization.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3de4b105-363c-482c-a409-baac83a01bfc")]
	public interface nsITimer
	{
		
		/// <summary>
        /// Initialize a timer that will fire after the said delay.
        /// A user must keep a reference to this timer till it is
        /// is no longer needed or has been cancelled.
        ///
        /// @param aObserver   the callback object that observes the
        /// ``timer-callback'' topic with the subject being
        /// the timer itself when the timer fires:
        ///
        /// observe(nsISupports aSubject, => nsITimer
        /// string aTopic,        => ``timer-callback''
        /// wstring data          =>  null
        ///
        /// @param aDelay      delay in milliseconds for timer to fire
        /// @param aType       timer type per TYPE* consts defined above
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init([MarshalAs(UnmanagedType.Interface)] nsIObserver aObserver, uint aDelay, uint aType);
		
		/// <summary>
        /// Initialize a timer to fire after the given millisecond interval.
        /// This version takes a function to call and a closure to pass to
        /// that function.
        ///
        /// @param aFunc      The function to invoke
        /// @param aClosure   An opaque pointer to pass to that function
        /// @param aDelay     The millisecond interval
        /// @param aType      Timer type per TYPE* consts defined above
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitWithFuncCallback(System.IntPtr aCallback, System.IntPtr aClosure, uint aDelay, uint aType);
		
		/// <summary>
        /// Initialize a timer to fire after the given millisecond interval.
        /// This version takes a function to call.
        ///
        /// @param aFunc      nsITimerCallback interface to call when timer expires
        /// @param aDelay     The millisecond interval
        /// @param aType      Timer type per TYPE* consts defined above
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitWithCallback([MarshalAs(UnmanagedType.Interface)] nsITimerCallback aCallback, uint aDelay, uint aType);
		
		/// <summary>
        /// Cancel the timer.  This method works on all types, not just on repeating
        /// timers -- you might want to cancel a TYPE_ONE_SHOT timer, and even reuse
        /// it by re-initializing it (to avoid object destruction and creation costs
        /// by conserving one timer instance).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Cancel();
		
		/// <summary>
        /// Like initWithFuncCallback, but also takes a name for the timer; the name
        /// will be used when timer profiling is enabled via the "TimerFirings" log
        /// module.
        ///
        /// @param aFunc      The function to invoke
        /// @param aClosure   An opaque pointer to pass to that function
        /// @param aDelay     The millisecond interval
        /// @param aType      Timer type per TYPE* consts defined above
        /// @param aName      The timer's name
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitWithNamedFuncCallback(System.IntPtr aCallback, System.IntPtr aClosure, uint aDelay, uint aType, [MarshalAs(UnmanagedType.LPStr)] string aName);
		
		/// <summary>
        /// Like initWithNamedFuncCallback, but instead of a timer name it takes a
        /// callback that will provide a name when the timer fires.
        ///
        /// @param aFunc      The function to invoke
        /// @param aClosure   An opaque pointer to pass to that function
        /// @param aDelay     The millisecond interval
        /// @param aType      Timer type per TYPE* consts defined above
        /// @param aNameCallback  The callback function
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitWithNameableFuncCallback(System.IntPtr aCallback, System.IntPtr aClosure, uint aDelay, uint aType, System.IntPtr aNameCallback);
		
		/// <summary>
        /// The millisecond delay of the timeout.
        ///
        /// NOTE: Re-setting the delay on a one-shot timer that has already fired
        /// doesn't restart the timer. Call one of the init() methods to restart
        /// a one-shot timer.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetDelayAttribute();
		
		/// <summary>
        /// The millisecond delay of the timeout.
        ///
        /// NOTE: Re-setting the delay on a one-shot timer that has already fired
        /// doesn't restart the timer. Call one of the init() methods to restart
        /// a one-shot timer.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDelayAttribute(uint aDelay);
		
		/// <summary>
        /// The timer type - one of the above TYPE_* constants.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetTypeAttribute();
		
		/// <summary>
        /// The timer type - one of the above TYPE_* constants.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetTypeAttribute(uint aType);
		
		/// <summary>
        /// The opaque pointer pass to initWithFuncCallback.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetClosureAttribute();
		
		/// <summary>
        /// The nsITimerCallback object passed to initWithCallback.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsITimerCallback GetCallbackAttribute();
		
		/// <summary>
        /// The nsIEventTarget where the callback will be dispatched. Note that this
        /// target may only be set before the call to one of the init methods above.
        ///
        /// By default the target is the thread that created the timer.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIEventTarget GetTargetAttribute();
		
		/// <summary>
        /// The nsIEventTarget where the callback will be dispatched. Note that this
        /// target may only be set before the call to one of the init methods above.
        ///
        /// By default the target is the thread that created the timer.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetTargetAttribute([MarshalAs(UnmanagedType.Interface)] nsIEventTarget aTarget);
	}
	
	/// <summary>nsITimerConsts </summary>
	public class nsITimerConsts
	{
		
		// <summary>
        // Type of a timer that fires once only.
        // </summary>
		public const short TYPE_ONE_SHOT = 0;
		
		// <summary>
        // After firing, a TYPE_REPEATING_SLACK timer is stopped and not restarted
        // until its callback completes.  Specified timer period will be at least
        // the time between when processing for last firing the callback completes
        // and when the next firing occurs.
        //
        // This is the preferable repeating type for most situations.
        // </summary>
		public const short TYPE_REPEATING_SLACK = 1;
		
		// <summary>
        // TYPE_REPEATING_PRECISE is just a synonym for
        // TYPE_REPEATING_PRECISE_CAN_SKIP. They used to be distinct, but the old
        // TYPE_REPEATING_PRECISE kind was similar to TYPE_REPEATING_PRECISE_CAN_SKIP
        // while also being less useful. So the distinction was removed.
        // </summary>
		public const short TYPE_REPEATING_PRECISE = 2;
		
		// <summary>
        // A TYPE_REPEATING_PRECISE_CAN_SKIP repeating timer aims to have constant
        // period between firings.  The processing time for each timer callback
        // should not influence the timer period.  However this timer type
        // guarantees that it will not queue up new events to fire the callback
        // until the previous callback event finishes firing.  If the callback
        // takes a long time, then the next callback will be scheduled immediately
        // afterward, but only once.  This is the only non-slack timer available.
        // </summary>
		public const short TYPE_REPEATING_PRECISE_CAN_SKIP = 3;
	}
}
