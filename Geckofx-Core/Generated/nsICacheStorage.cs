// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICacheStorage.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// Representation of a cache storage. There can be just-in-mem,
    /// in-mem+on-disk, in-mem+on-disk+app-cache or just a specific
    /// app-cache storage.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("35d104a6-d252-4fd4-8a56-3c14657cad3b")]
	public interface nsICacheStorage
	{
		
		/// <summary>
        /// Asynchronously opens a cache entry for the specified URI.
        /// Result is fetched asynchronously via the callback.
        ///
        /// @param aURI
        /// The URI to search in cache or to open for writting.
        /// @param aIdExtension
        /// Any string that will extend (distinguish) the entry.  Two entries
        /// with the same aURI but different aIdExtension will be comletely
        /// different entries.  If you don't know what aIdExtension should be
        /// leave it empty.
        /// @param aFlags
        /// OPEN_NORMALLY - open cache entry normally for read and write
        /// OPEN_TRUNCATE - delete any existing entry before opening it
        /// OPEN_READONLY - don't create an entry if there is none
        /// OPEN_PRIORITY - give this request a priority over others
        /// OPEN_BYPASS_IF_BUSY - backward compatibility only, LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
        /// CHECK_MULTITHREADED - onCacheEntryCheck may be called on any thread, consumer
        /// implementation is thread-safe
        /// @param aCallback
        /// The consumer that receives the result.
        /// IMPORTANT: The callback may be called sooner the method returns.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncOpenURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension, uint aFlags, [MarshalAs(UnmanagedType.Interface)] nsICacheEntryOpenCallback aCallback);
		
		/// <summary>
        /// Immediately opens a new and empty cache entry in the storage, any existing
        /// entries are immediately doomed.  This is similar to the recreate() method
        /// on nsICacheEntry.
        ///
        /// Storage may not implement this method and throw NS_ERROR_NOT_IMPLEMENTED.
        /// In that case consumer must use asyncOpen with OPEN_TRUNCATE flag and get
        /// the new entry via a callback.
        ///
        /// @param aURI @see asyncOpenURI
        /// @param aIdExtension @see asyncOpenURI
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsICacheEntry OpenTruncate([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension);
		
		/// <summary>
        /// Synchronously check on existance of an entry.  In case of disk entries
        /// this uses information from the cache index.  When the index data are not
        /// up to date or index is still building, NS_ERROR_NOT_AVAILABLE is thrown.
        /// The same error may throw any storage implementation that cannot determine
        /// entry state without blocking the caller.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Exists([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension);
		
		/// <summary>
        /// Asynchronously removes an entry belonging to the URI from the cache.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncDoomURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension, [MarshalAs(UnmanagedType.Interface)] nsICacheEntryDoomCallback aCallback);
		
		/// <summary>
        /// Asynchronously removes all cached entries under this storage.
        /// NOTE: Disk storage also evicts memory storage.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncEvictStorage([MarshalAs(UnmanagedType.Interface)] nsICacheEntryDoomCallback aCallback);
		
		/// <summary>
        /// Visits the storage and its entries.
        /// NOTE: Disk storage also visits memory storage.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncVisitStorage([MarshalAs(UnmanagedType.Interface)] nsICacheStorageVisitor aVisitor, [MarshalAs(UnmanagedType.U1)] bool aVisitEntries);
	}
	
	/// <summary>nsICacheStorageConsts </summary>
	public class nsICacheStorageConsts
	{
		
		// <summary>
        // Placeholder for specifying "no special flags" during open.
        // </summary>
		public const long OPEN_NORMALLY = 0;
		
		// <summary>
        // Rewrite any existing data when opening a URL.
        // </summary>
		public const long OPEN_TRUNCATE = 1<<0;
		
		// <summary>
        // Only open an existing entry.  Don't create a new one.
        // </summary>
		public const long OPEN_READONLY = 1<<1;
		
		// <summary>
        // Use for first-paint blocking loads.
        // </summary>
		public const long OPEN_PRIORITY = 1<<2;
		
		// <summary>
        // Bypass the cache load when write is still in progress.
        // </summary>
		public const long OPEN_BYPASS_IF_BUSY = 1<<3;
		
		// <summary>
        // Perform the cache entry check (onCacheEntryCheck invocation) on any thread
        // for optimal perfomance optimization.  If this flag is not specified it is
        // ensured that onCacheEntryCheck is called on the same thread as respective
        // asyncOpen has been called.
        // </summary>
		public const long CHECK_MULTITHREADED = 1<<4;
		
		// <summary>
        // Don't automatically update any 'last used' metadata of the entry.
        // </summary>
		public const long OPEN_SECRETLY = 1<<5;
	}
}
