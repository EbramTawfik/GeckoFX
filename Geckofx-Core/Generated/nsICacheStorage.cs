// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICacheStorage.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// Representation of a cache storage. There can be just-in-mem,
    /// in-mem+on-disk, in-mem+on-disk+app-cache or just a specific
    /// app-cache storage.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("d983ba0c-433f-4017-abc1-93af737c82e4")]
	public interface nsICacheStorage
	{
		
		/// <summary>
        /// Asynchronously opens a cache entry for the specified URI.
        /// Result is fetched asynchronously via the callback.
        ///
        /// @param aURI
        /// The URI to search in cache or to open for writting.
        /// @param aIdExtension
        /// Any string that will extend (distinguish) the entry.  Two entries
        /// with the same aURI but different aIdExtension will be comletely
        /// different entries.  If you don't know what aIdExtension should be
        /// leave it empty.
        /// @param aFlags
        /// OPEN_NORMALLY - open cache entry normally for read and write
        /// OPEN_TRUNCATE - delete any existing entry before opening it
        /// OPEN_READONLY - don't create an entry if there is none
        /// OPEN_PRIORITY - give this request a priority over others
        /// OPEN_BYPASS_IF_BUSY - backward compatibility only, LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
        /// CHECK_MULTITHREADED - onCacheEntryCheck may be called on any thread, consumer
        /// implementation is thread-safe
        /// @param aCallback
        /// The consumer that receives the result.
        /// IMPORTANT: The callback may be called sooner the method returns.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncOpenURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension, uint aFlags, [MarshalAs(UnmanagedType.Interface)] nsICacheEntryOpenCallback aCallback);
		
		/// <summary>
        /// Asynchronously removes an entry belonging to the URI from the cache.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncDoomURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aIdExtension, [MarshalAs(UnmanagedType.Interface)] nsICacheEntryDoomCallback aCallback);
		
		/// <summary>
        /// Asynchronously removes all cached entries under this storage.
        /// NOTE: Disk storage also evicts memory storage.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncEvictStorage([MarshalAs(UnmanagedType.Interface)] nsICacheEntryDoomCallback aCallback);
		
		/// <summary>
        /// Visits the storage and its entries.
        /// NOTE: Disk storage also visits memory storage.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncVisitStorage([MarshalAs(UnmanagedType.Interface)] nsICacheStorageVisitor aVisitor, [MarshalAs(UnmanagedType.U1)] bool aVisitEntries);
	}
	
	/// <summary>nsICacheStorageConsts </summary>
	public class nsICacheStorageConsts
	{
		
		// <summary>
        // Placeholder for specifying "no special flags" during open.
        // </summary>
		public const long OPEN_NORMALLY = 0;
		
		// <summary>
        // Rewrite any existing data when opening a URL.
        // </summary>
		public const long OPEN_TRUNCATE = 1<<0;
		
		// <summary>
        // Only open an existing entry.  Don't create a new one.
        // </summary>
		public const long OPEN_READONLY = 1<<1;
		
		// <summary>
        // Use for first-paint blocking loads.
        // </summary>
		public const long OPEN_PRIORITY = 1<<2;
		
		// <summary>
        // Bypass the cache load when write is still in progress.
        // </summary>
		public const long OPEN_BYPASS_IF_BUSY = 1<<3;
		
		// <summary>
        // Perform the cache entry check (onCacheEntryCheck invocation) on any thread
        // for optimal perfomance optimization.  If this flag is not specified it is
        // ensured that onCacheEntryCheck is called on the same thread as respective
        // asyncOpen has been called.
        // </summary>
		public const long CHECK_MULTITHREADED = 1<<4;
	}
}
