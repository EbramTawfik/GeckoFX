// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIWindowsRegKey.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// This interface is designed to provide scriptable access to the Windows
    /// registry system ("With Great Power Comes Great Responsibility").  The
    /// interface represents a single key in the registry.
    ///
    /// This interface is highly Win32 specific.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2555b930-d64f-437e-9be7-0a2cb252c1f4")]
	public interface nsIWindowsRegKey
	{
		
		/// <summary>
        /// This attribute exposes the native HKEY and is available to provide C++
        /// consumers with the flexibility of making other Windows registry API calls
        /// that are not exposed via this interface.
        ///
        /// It is possible to initialize this object by setting an HKEY on it.  In
        /// that case, it is the responsibility of the consumer setting the HKEY to
        /// ensure that it is a valid HKEY.
        ///
        /// WARNING: Setting the key does not close the old key.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetKeyAttribute();
		
		/// <summary>
        /// This attribute exposes the native HKEY and is available to provide C++
        /// consumers with the flexibility of making other Windows registry API calls
        /// that are not exposed via this interface.
        ///
        /// It is possible to initialize this object by setting an HKEY on it.  In
        /// that case, it is the responsibility of the consumer setting the HKEY to
        /// ensure that it is a valid HKEY.
        ///
        /// WARNING: Setting the key does not close the old key.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetKeyAttribute(System.IntPtr aKey);
		
		/// <summary>
        /// This method closes the key.  If the key is already closed, then this
        /// method does nothing.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Close();
		
		/// <summary>
        /// This method opens an existing key.  This method fails if the key
        /// does not exist.
        ///
        /// NOTE: On 32-bit Windows, it is valid to pass any HKEY as the rootKey
        /// parameter of this function.  However, for compatibility with 64-bit
        /// Windows, that usage should probably be avoided in favor of openChild.
        ///
        /// @param rootKey
        /// A root key defined above or any valid HKEY on 32-bit Windows.
        /// @param relPath
        /// A relative path from the given root key.
        /// @param mode
        /// Access mode, which is a bit-wise OR of the ACCESS_ values defined
        /// above.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Open(uint rootKey, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase relPath, uint mode);
		
		/// <summary>
        /// This method opens an existing key or creates a new key.
        ///
        /// NOTE: On 32-bit Windows, it is valid to pass any HKEY as the rootKey
        /// parameter of this function.  However, for compatibility with 64-bit
        /// Windows, that usage should probably be avoided in favor of createChild.
        ///
        /// @param rootKey
        /// A root key defined above or any valid HKEY on 32-bit Windows.
        /// @param relPath
        /// A relative path from the given root key.
        /// @param mode
        /// Access mode, which is a bit-wise OR of the ACCESS_ values defined
        /// above.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Create(uint rootKey, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase relPath, uint mode);
		
		/// <summary>
        /// This method opens a subkey relative to this key.  This method fails if the
        /// key does not exist.
        ///
        /// @return nsIWindowsRegKey for the newly opened subkey.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWindowsRegKey OpenChild([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase relPath, uint mode);
		
		/// <summary>
        /// This method opens or creates a subkey relative to this key.
        ///
        /// @return nsIWindowsRegKey for the newly opened or created subkey.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWindowsRegKey CreateChild([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase relPath, uint mode);
		
		/// <summary>
        /// This attribute returns the number of child keys.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetChildCountAttribute();
		
		/// <summary>
        /// This method returns the name of the n'th child key.
        ///
        /// @param index
        /// The index of the requested child key.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetChildName(uint index, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// This method checks to see if the key has a child by the given name.
        ///
        /// @param name
        /// The name of the requested child key.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool HasChild([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This attribute returns the number of values under this key.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetValueCountAttribute();
		
		/// <summary>
        /// This method returns the name of the n'th value under this key.
        ///
        /// @param index
        /// The index of the requested value.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetValueName(uint index, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// This method checks to see if the key has a value by the given name.
        ///
        /// @param name
        /// The name of the requested value.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool HasValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This method removes a child key and all of its values.  This method will
        /// fail if the key has any children of its own.
        ///
        /// @param relPath
        /// The relative path from this key to the key to be removed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveChild([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase relPath);
		
		/// <summary>
        /// This method removes the value with the given name.
        ///
        /// @param name
        /// The name of the value to be removed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This method returns the type of the value with the given name.  The return
        /// value is one of the "TYPE_" constants defined above.
        ///
        /// @param name
        /// The name of the value to query.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetValueType([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This method reads the string contents of the named value as a Unicode
        /// string.
        ///
        /// @param name
        /// The name of the value to query.  This parameter can be the empty
        /// string to request the key's default value.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReadStringValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// This method reads the integer contents of the named value.
        ///
        /// @param name
        /// The name of the value to query.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint ReadIntValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This method reads the 64-bit integer contents of the named value.
        ///
        /// @param name
        /// The name of the value to query.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint ReadInt64Value([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name);
		
		/// <summary>
        /// This method reads the binary contents of the named value under this key.
        ///
        /// JavaScript callers should take care with the result of this method since
        /// it will be byte-expanded to form a JS string.  (The binary data will be
        /// treated as an ISO-Latin-1 character string, which it is not).
        ///
        /// @param name
        /// The name of the value to query.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ReadBinaryValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// This method writes the unicode string contents of the named value.  The
        /// value will be created if it does not already exist.
        ///
        /// @param name
        /// The name of the value to modify.  This parameter can be the empty
        /// string to modify the key's default value.
        /// @param data
        /// The data for the value to modify.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteStringValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase data);
		
		/// <summary>
        /// This method writes the integer contents of the named value.  The value
        /// will be created if it does not already exist.
        ///
        /// @param name
        /// The name of the value to modify.
        /// @param data
        /// The data for the value to modify.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteIntValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, uint data);
		
		/// <summary>
        /// This method writes the 64-bit integer contents of the named value.  The
        /// value will be created if it does not already exist.
        ///
        /// @param name
        /// The name of the value to modify.
        /// @param data
        /// The data for the value to modify.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteInt64Value([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, ulong data);
		
		/// <summary>
        /// This method writes the binary contents of the named value.  The value will
        /// be created if it does not already exist.
        ///
        /// JavaScript callers should take care with the value passed to this method
        /// since it will be truncated from a JS string (unicode) to a ISO-Latin-1
        /// string.  (The binary data will be treated as an ISO-Latin-1 character
        /// string, which it is not).  So, JavaScript callers should only pass
        /// character values in the range \u0000 to \u00FF, or else data loss will
        /// occur.
        ///
        /// @param name
        /// The name of the value to modify.
        /// @param data
        /// The data for the value to modify.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void WriteBinaryValue([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase name, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase data);
		
		/// <summary>
        /// This method starts watching the key to see if any of its values have
        /// changed.  The key must have been opened with mode including ACCESS_NOTIFY.
        /// If recurse is true, then this key and any of its descendant keys are
        /// watched.  Otherwise, only this key is watched.
        ///
        /// @param recurse
        /// Indicates whether or not to also watch child keys.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StartWatching([MarshalAs(UnmanagedType.Bool)] bool recurse);
		
		/// <summary>
        /// This method stops any watching of the key initiated by a call to
        /// startWatching.  This method does nothing if the key is not being watched.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopWatching();
		
		/// <summary>
        /// This method returns true if the key is being watched for changes (i.e.,
        /// if startWatching() was called).
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsWatching();
		
		/// <summary>
        /// This method returns true if the key has changed and false otherwise.
        /// This method will always return false if startWatching was not called.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool HasChanged();
	}
}
