// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file extIApplication.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// Interface that gives simplified access to the console
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ae8482e0-aa5a-11db-abbd-0800200c9a66")]
	public interface extIConsole
	{
		
		/// <summary>
        /// Sends a given string to the console.
        /// @param   aMsg
        /// The text to send to the console
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Log([MarshalAs(UnmanagedType.LPStruct)] nsAString aMsg);
		
		/// <summary>
        /// Opens the error console window. The console window
        /// is focused if already open.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Open();
	}
	
	/// <summary>
    /// Interface holds information about an event.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("05281820-ab62-11db-abbd-0800200c9a66")]
	public interface extIEventItem
	{
		
		/// <summary>
        /// The name of the event
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aType);
		
		/// <summary>
        /// Can hold extra details and data associated with the event. This
        /// is optional and event specific. If the event does not send extra
        /// details, this is null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant GetDataAttribute();
		
		/// <summary>
        /// Cancels the event if it is cancelable.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PreventDefault();
	}
	
	/// <summary>
    /// Interface used as a callback for listening to events.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2dfe3a50-ab2f-11db-abbd-0800200c9a66")]
	public interface extIEventListener
	{
		
		/// <summary>
        /// This method is called whenever an event occurs of the type for which
        /// the extIEventListener interface was registered.
        ///
        /// @param   aEvent
        /// The extIEventItem associated with the event.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void HandleEvent(extIEventItem aEvent);
	}
	
	/// <summary>
    /// Interface for supporting custom events.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3a8ec9d0-ab19-11db-abbd-0800200c9a66")]
	public interface extIEvents
	{
		
		/// <summary>
        /// Adds an event listener to the list. If multiple identical event listeners
        /// are registered on the same event target with the same parameters the
        /// duplicate instances are discarded. They do not cause the EventListener
        /// to be called twice and since they are discarded they do not need to be
        /// removed with the removeListener method.
        ///
        /// @param   aEvent
        /// The name of an event
        /// @param   aListener
        /// The reference to a listener
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddListener([MarshalAs(UnmanagedType.LPStruct)] nsAString aEvent, extIEventListener aListener);
		
		/// <summary>
        /// Removes an event listener from the list. Calling remove
        /// with arguments which do not identify any currently registered
        /// event listener has no effect.
        /// @param   aEvent
        /// The name of an event
        /// @param   aListener
        /// The reference to a listener
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveListener([MarshalAs(UnmanagedType.LPStruct)] nsAString aEvent, extIEventListener aListener);
	}
	
	/// <summary>
    /// Interface for simplified access to preferences. The interface has a
    /// predefined root preference branch. The root branch is set based on the
    /// context of the owner. For example, an extension's preferences have a root
    /// of "extensions.<extensionid>.", while the application level preferences
    /// have an empty root. All preference "aName" parameters used in this interface
    /// are relative to the root branch.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ce697d40-aa5a-11db-abbd-0800200c9a66")]
	public interface extIPreferenceBranch
	{
		
		/// <summary>
        /// The name of the branch root.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetRootAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aRoot);
		
		/// <summary>
        /// Array of extIPreference listing all preferences in this branch.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant GetAllAttribute();
		
		/// <summary>
        /// The events object for the preferences
        /// supports: "change"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIEvents GetEventsAttribute();
		
		/// <summary>
        /// Check to see if a preference exists.
        /// @param   aName
        /// The name of preference
        /// @returns true if the preference exists, false if not
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Has([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Gets an object representing a preference
        /// @param   aName
        /// The name of preference
        /// @returns a preference object, or null if the preference does not exist
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIPreference Get([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Gets the value of a preference. Returns a default value if
        /// the preference does not exist.
        /// @param   aName
        /// The name of preference
        /// @param   aDefaultValue
        /// The value to return if preference does not exist
        /// @returns value of the preference or the given default value if preference
        /// does not exists.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant GetValue([MarshalAs(UnmanagedType.LPStruct)] nsAString aName, [MarshalAs(UnmanagedType.Interface)] nsIVariant aDefaultValue);
		
		/// <summary>
        /// Sets the value of a storage item with the given name.
        /// @param   aName
        /// The name of an item
        /// @param   aValue
        /// The value to assign to the item
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetValue([MarshalAs(UnmanagedType.LPStruct)] nsAString aName, [MarshalAs(UnmanagedType.Interface)] nsIVariant aValue);
		
		/// <summary>
        /// Resets all preferences in a branch back to their default values.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Reset();
	}
	
	/// <summary>
    /// Interface for accessing a single preference. The data is not cached.
    /// All reads access the current state of the preference.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2C7462E2-72C2-4473-9007-0E6AE71E23CA")]
	public interface extIPreference
	{
		
		/// <summary>
        /// The name of the preference.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// A string representing the type of preference (String, Boolean, or Number).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aType);
		
		/// <summary>
        /// Get/Set the value of the preference.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant GetValueAttribute();
		
		/// <summary>
        /// Get/Set the value of the preference.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetValueAttribute([MarshalAs(UnmanagedType.Interface)] nsIVariant aValue);
		
		/// <summary>
        /// Get the locked state of the preference. Set to a boolean value to (un)lock it.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetLockedAttribute();
		
		/// <summary>
        /// Get the locked state of the preference. Set to a boolean value to (un)lock it.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetLockedAttribute([MarshalAs(UnmanagedType.Bool)] bool aLocked);
		
		/// <summary>
        /// Check if a preference has been modified by the user, or not.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetModifiedAttribute();
		
		/// <summary>
        /// The preference branch that contains this preference.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIPreferenceBranch GetBranchAttribute();
		
		/// <summary>
        /// The events object for this preference.
        /// supports: "change"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIEvents GetEventsAttribute();
		
		/// <summary>
        /// Resets a preference back to its default values.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Reset();
	}
	
	/// <summary>
    /// Interface representing an extension
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("10cee02c-f6e0-4d61-ab27-c16572b18c46")]
	public interface extIExtension
	{
		
		/// <summary>
        /// The id of the extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetIdAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aId);
		
		/// <summary>
        /// The name of the extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Check if the extension is currently enabled, or not.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetEnabledAttribute();
		
		/// <summary>
        /// The version number of the extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetVersionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aVersion);
		
		/// <summary>
        /// Indicates whether this is the extension's first run after install
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetFirstRunAttribute();
		
		/// <summary>
        /// The preferences object for the extension. Defaults to the
        /// "extensions.<extensionid>." branch.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIPreferenceBranch GetPrefsAttribute();
		
		/// <summary>
        /// The storage object for the extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extISessionStorage GetStorageAttribute();
		
		/// <summary>
        /// The events object for the extension.
        /// supports: "uninstall"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIEvents GetEventsAttribute();
	}
	
	/// <summary>
    /// Interface representing a list of all installed extensions
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("de281930-aa5a-11db-abbd-0800200c9a66")]
	public interface extIExtensions
	{
		
		/// <summary>
        /// Array of extIExtension listing all extensions in the application.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant GetAllAttribute();
		
		/// <summary>
        /// Determines if an extension exists with the given id.
        /// @param   aId
        /// The id of an extension
        /// @returns true if an extension exists with the given id,
        /// false otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Has([MarshalAs(UnmanagedType.LPStruct)] nsAString aId);
		
		/// <summary>
        /// Gets a extIExtension object for an extension.
        /// @param   aId
        /// The id of an extension
        /// @returns An extension object or null if no extension exists
        /// with the given id.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIExtension Get([MarshalAs(UnmanagedType.LPStruct)] nsAString aId);
	}
	
	/// <summary>
    /// Interface representing a callback that receives an array of extIExtensions
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2571cbb5-550d-4400-8038-75df9b553f98")]
	public interface extIExtensionsCallback
	{
		
		/// <summary>
        /// Interface representing a callback that receives an array of extIExtensions
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Callback([MarshalAs(UnmanagedType.Interface)] nsIVariant extensions);
	}
	
	/// <summary>
    /// Interface representing a simple storage system
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("0787ac44-29b9-4889-b97f-13573aec6971")]
	public interface extISessionStorage
	{
		
		/// <summary>
        /// The events object for the storage
        /// supports: "change"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIEvents GetEventsAttribute();
		
		/// <summary>
        /// Determines if a storage item exists with the given name.
        /// @param   aName
        /// The name of an item
        /// @returns true if an item exists with the given name,
        /// false otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Has([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Sets the value of a storage item with the given name.
        /// @param   aName
        /// The name of an item
        /// @param   aValue
        /// The value to assign to the item
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Set([MarshalAs(UnmanagedType.LPStruct)] nsAString aName, [MarshalAs(UnmanagedType.Interface)] nsIVariant aValue);
		
		/// <summary>
        /// Gets the value of a storage item with the given name. Returns a
        /// default value if the item does not exist.
        /// @param   aName
        /// The name of an item
        /// @param   aDefaultValue
        /// The value to return if no item exists with the given name
        /// @returns value of the item or the given default value if no item
        /// exists with the given name.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIVariant Get([MarshalAs(UnmanagedType.LPStruct)] nsAString aName, [MarshalAs(UnmanagedType.Interface)] nsIVariant aDefaultValue);
	}
	
	/// <summary>extIApplication </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2be87909-0817-4292-acfa-fc39be53be3f")]
	public interface extIApplication
	{
		
		/// <summary>
        /// The id of the application.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetIdAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aId);
		
		/// <summary>
        /// The name of the application.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// The version number of the application.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetVersionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aVersion);
		
		/// <summary>
        /// The console object for the application.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIConsole GetConsoleAttribute();
		
		/// <summary>
        /// The extensions object for the application. Contains a list
        /// of all installed extensions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetExtensions(extIExtensionsCallback aCallback);
		
		/// <summary>
        /// The preferences object for the application. Defaults to an empty
        /// root branch.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIPreferenceBranch GetPrefsAttribute();
		
		/// <summary>
        /// The storage object for the application.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extISessionStorage GetStorageAttribute();
		
		/// <summary>
        /// The events object for the application.
        /// supports: "load", "ready", "quit", "unload"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		extIEvents GetEventsAttribute();
		
		/// <summary>
        /// Quits the application (if nobody objects to quit-application-requested).
        /// @returns whether quitting will proceed
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Quit();
		
		/// <summary>
        /// Restarts the application (if nobody objects to quit-application-requested).
        /// @returns whether restarting will proceed
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Restart();
	}
}
