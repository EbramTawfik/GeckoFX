// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIMIMEInfo.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// nsIHandlerInfo gives access to the information about how a given protocol
    /// scheme or MIME-type is handled.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("325e56a7-3762-4312-aec7-f1fcf84b4145")]
	public interface nsIHandlerInfo
	{
		
		/// <summary>
        /// The type of this handler info.  For MIME handlers, this is the MIME type.
        /// For protocol handlers, it's the scheme.
        ///
        /// @return String representing the type.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString  aType);
		
		/// <summary>
        /// A human readable description of the handler type
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDescription);
		
		/// <summary>
        /// A human readable description of the handler type
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDescription);
		
		/// <summary>
        /// The application the user has said they want associated with this content
        /// type. This is not always guaranteed to be set!!
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIHandlerApp  GetPreferredApplicationHandlerAttribute();
		
		/// <summary>
        /// The application the user has said they want associated with this content
        /// type. This is not always guaranteed to be set!!
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPreferredApplicationHandlerAttribute([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aPreferredApplicationHandler);
		
		/// <summary>
        /// Applications that can handle this content type.
        ///
        /// The list will include the preferred handler, if any.  Elements of this
        /// array are nsIHandlerApp objects, and this attribute will always reference
        /// an array, whether or not there are any possible handlers.  If there are
        /// no possible handlers, the array will contain no elements, so just check
        /// its length (nsIArray::length) to see if there are any possible handlers.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIMutableArray  GetPossibleApplicationHandlersAttribute();
		
		/// <summary>
        /// Indicates whether a default application handler exists,
        /// i.e. whether launchWithFile with action = useSystemDefault is possible
        /// and defaultDescription will contain usable information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.Boolean  GetHasDefaultHandlerAttribute();
		
		/// <summary>
        /// A pretty name description of the associated default application. Only
        /// usable if hasDefaultHandler is true.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDefaultDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDefaultDescription);
		
		/// <summary>
        /// Launches the application with the specified URI, in a way that
        /// depends on the value of preferredAction. preferredAction must be
        /// useHelperApp or useSystemDefault.
        ///
        /// @note Only the URI scheme is used to determine how to launch.  This is
        /// essentially a pass-by-value operation.  This means that in the case of
        /// a file: URI, the handler that is registered for file: will be launched
        /// and our code will not make any decision based on the content-type or
        /// extension, though the invoked file: handler is free to do so.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        /// The window to parent the dialog against, and, if a web handler
        /// is chosen, it is loaded in this window as well.  See
        /// nsIHandlerApp.launchWithURI for more details.
        ///
        /// @throw NS_ERROR_INVALID_ARG if preferredAction is not valid for this
        /// call. Other exceptions may be thrown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
		
		/// <summary>
        /// preferredAction is how the user specified they would like to handle
        /// this content type: save to disk, use specified helper app, use OS
        /// default handler or handle using navigator; possible value constants
        /// listed below
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetPreferredActionAttribute();
		
		/// <summary>
        /// preferredAction is how the user specified they would like to handle
        /// this content type: save to disk, use specified helper app, use OS
        /// default handler or handle using navigator; possible value constants
        /// listed below
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPreferredActionAttribute(System.IntPtr aPreferredAction);
		
		/// <summary>
        /// alwaysAskBeforeHandling: if true, we should always give the user a
        /// dialog asking how to dispose of this content.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.Boolean  GetAlwaysAskBeforeHandlingAttribute();
		
		/// <summary>
        /// alwaysAskBeforeHandling: if true, we should always give the user a
        /// dialog asking how to dispose of this content.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAlwaysAskBeforeHandlingAttribute(System.Boolean  aAlwaysAskBeforeHandling);
	}
	
	/// <summary>
    /// nsIMIMEInfo extends nsIHandlerInfo with a bunch of information specific to
    /// MIME content-types. There is a one-to-many relationship between MIME types
    /// and file extensions. This means that a MIMEInfo object may have multiple
    /// file extensions associated with it.  However, the reverse is not true.
    ///
    /// MIMEInfo objects are generally retrieved from the MIME Service
    /// @see nsIMIMEService
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1c21acef-c7a1-40c6-9d40-a20480ee53a1")]
	public interface nsIMIMEInfo : nsIHandlerInfo
	{
		
		/// <summary>
        /// The type of this handler info.  For MIME handlers, this is the MIME type.
        /// For protocol handlers, it's the scheme.
        ///
        /// @return String representing the type.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString  aType);
		
		/// <summary>
        /// A human readable description of the handler type
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDescription);
		
		/// <summary>
        /// A human readable description of the handler type
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDescription);
		
		/// <summary>
        /// The application the user has said they want associated with this content
        /// type. This is not always guaranteed to be set!!
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIHandlerApp  GetPreferredApplicationHandlerAttribute();
		
		/// <summary>
        /// The application the user has said they want associated with this content
        /// type. This is not always guaranteed to be set!!
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetPreferredApplicationHandlerAttribute([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aPreferredApplicationHandler);
		
		/// <summary>
        /// Applications that can handle this content type.
        ///
        /// The list will include the preferred handler, if any.  Elements of this
        /// array are nsIHandlerApp objects, and this attribute will always reference
        /// an array, whether or not there are any possible handlers.  If there are
        /// no possible handlers, the array will contain no elements, so just check
        /// its length (nsIArray::length) to see if there are any possible handlers.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIMutableArray  GetPossibleApplicationHandlersAttribute();
		
		/// <summary>
        /// Indicates whether a default application handler exists,
        /// i.e. whether launchWithFile with action = useSystemDefault is possible
        /// and defaultDescription will contain usable information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.Boolean  GetHasDefaultHandlerAttribute();
		
		/// <summary>
        /// A pretty name description of the associated default application. Only
        /// usable if hasDefaultHandler is true.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetDefaultDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDefaultDescription);
		
		/// <summary>
        /// Launches the application with the specified URI, in a way that
        /// depends on the value of preferredAction. preferredAction must be
        /// useHelperApp or useSystemDefault.
        ///
        /// @note Only the URI scheme is used to determine how to launch.  This is
        /// essentially a pass-by-value operation.  This means that in the case of
        /// a file: URI, the handler that is registered for file: will be launched
        /// and our code will not make any decision based on the content-type or
        /// extension, though the invoked file: handler is free to do so.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        /// The window to parent the dialog against, and, if a web handler
        /// is chosen, it is loaded in this window as well.  See
        /// nsIHandlerApp.launchWithURI for more details.
        ///
        /// @throw NS_ERROR_INVALID_ARG if preferredAction is not valid for this
        /// call. Other exceptions may be thrown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
		
		/// <summary>
        /// preferredAction is how the user specified they would like to handle
        /// this content type: save to disk, use specified helper app, use OS
        /// default handler or handle using navigator; possible value constants
        /// listed below
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.IntPtr GetPreferredActionAttribute();
		
		/// <summary>
        /// preferredAction is how the user specified they would like to handle
        /// this content type: save to disk, use specified helper app, use OS
        /// default handler or handle using navigator; possible value constants
        /// listed below
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetPreferredActionAttribute(System.IntPtr aPreferredAction);
		
		/// <summary>
        /// alwaysAskBeforeHandling: if true, we should always give the user a
        /// dialog asking how to dispose of this content.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.Boolean  GetAlwaysAskBeforeHandlingAttribute();
		
		/// <summary>
        /// alwaysAskBeforeHandling: if true, we should always give the user a
        /// dialog asking how to dispose of this content.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetAlwaysAskBeforeHandlingAttribute(System.Boolean  aAlwaysAskBeforeHandling);
		
		/// <summary>
        /// Gives you an array of file types associated with this type.
        ///
        /// @return Number of elements in the array.
        /// @return Array of extensions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIUTF8StringEnumerator GetFileExtensions();
		
		/// <summary>
        /// Set File Extensions. Input is a comma delimited list of extensions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFileExtensions([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aExtensions);
		
		/// <summary>
        /// Returns whether or not the given extension is
        /// associated with this MIME info.
        ///
        /// @return TRUE if the association exists.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ExtensionExists([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aExtension);
		
		/// <summary>
        /// Append a given extension to the set of extensions
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AppendExtension([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aExtension);
		
		/// <summary>
        /// Returns the first extension association in
        /// the internal set of extensions.
        ///
        /// @return The first extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPrimaryExtensionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aPrimaryExtension);
		
		/// <summary>
        /// Returns the first extension association in
        /// the internal set of extensions.
        ///
        /// @return The first extension.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPrimaryExtensionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aPrimaryExtension);
		
		/// <summary>
        /// The MIME type of this MIMEInfo.
        ///
        /// @return String representing the MIME type.
        ///
        /// @deprecated  use nsIHandlerInfo::type instead.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetMIMETypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString  aMIMEType);
		
		/// <summary>
        /// Returns whether or not these two nsIMIMEInfos are logically
        /// equivalent.
        ///
        /// @returns PR_TRUE if the two are considered equal
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Equals([MarshalAs(UnmanagedType.Interface)] nsIMIMEInfo  aMIMEInfo);
		
		/// <summary>
        /// Returns a list of nsILocalHandlerApp objects containing
        /// handlers associated with this mimeinfo. Implemented per
        /// platform using information in this object to generate the
        /// best list. Typically used for an "open with" style user
        /// option.
        ///
        /// @return nsIArray of nsILocalHandlerApp
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIArray  GetPossibleLocalHandlersAttribute();
		
		/// <summary>
        /// Launches the application with the specified file, in a way that
        /// depends on the value of preferredAction. preferredAction must be
        /// useHelperApp or useSystemDefault.
        ///
        /// @param aFile The file to launch this application with.
        ///
        /// @throw NS_ERROR_INVALID_ARG if action is not valid for this function.
        /// Other exceptions may be thrown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LaunchWithFile([MarshalAs(UnmanagedType.Interface)] nsIFile  aFile);
	}
	
	/// <summary>
    /// nsIHandlerApp represents an external application that can handle content
    /// of some sort (either a MIME type or a protocol).
    ///
    /// FIXME: now that we've made nsIWebHandlerApp inherit from nsIHandlerApp,
    /// we should also try to make nsIWebContentHandlerInfo inherit from or possibly
    /// be replaced by nsIWebHandlerApp (bug 394710).
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8BDF20A4-9170-4548-AF52-78311A44F920")]
	public interface nsIHandlerApp
	{
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Whether or not the given handler app is logically equivalent to the
        /// invokant (i.e. they represent the same app).
        ///
        /// Two apps are the same if they are both either local or web handlers
        /// and their executables/URI templates and command line parameters are
        /// the same.
        ///
        /// @param aHandlerApp the handler app to compare to the invokant
        ///
        /// @returns true if the two are logically equivalent, false otherwise
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Equals([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aHandlerApp);
		
		/// <summary>
        /// Launches the application with the specified URI.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        ///
        /// Currently only relevant to web-handler apps.  If given, this
        /// represents the docshell to load the handler in and is passed
        /// through to nsIURILoader.openURI.  If this parameter is null or
        /// not present, the web handler app implementation will attempt to
        /// find/create a place to load the handler and do so.  As of this
        /// writing, it tries to load the web handler in a new window using
        /// nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
        /// have a more comprehensive strategy which could include handing
        /// off to the system default browser (bug 394479).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
	}
	
	/// <summary>
    /// nsILocalHandlerApp is a local OS-level executable
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("D36B6329-52AE-4f45-80F4-B2536AE5F8B2")]
	public interface nsILocalHandlerApp : nsIHandlerApp
	{
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Whether or not the given handler app is logically equivalent to the
        /// invokant (i.e. they represent the same app).
        ///
        /// Two apps are the same if they are both either local or web handlers
        /// and their executables/URI templates and command line parameters are
        /// the same.
        ///
        /// @param aHandlerApp the handler app to compare to the invokant
        ///
        /// @returns true if the two are logically equivalent, false otherwise
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool Equals([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aHandlerApp);
		
		/// <summary>
        /// Launches the application with the specified URI.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        ///
        /// Currently only relevant to web-handler apps.  If given, this
        /// represents the docshell to load the handler in and is passed
        /// through to nsIURILoader.openURI.  If this parameter is null or
        /// not present, the web handler app implementation will attempt to
        /// find/create a place to load the handler and do so.  As of this
        /// writing, it tries to load the web handler in a new window using
        /// nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
        /// have a more comprehensive strategy which could include handing
        /// off to the system default browser (bug 394479).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
		
		/// <summary>
        /// Pointer to the executable file used to handle content
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIFile  GetExecutableAttribute();
		
		/// <summary>
        /// Pointer to the executable file used to handle content
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetExecutableAttribute([MarshalAs(UnmanagedType.Interface)] nsIFile  aExecutable);
		
		/// <summary>
        /// Returns the current number of command line parameters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.UInt32  GetParameterCountAttribute();
		
		/// <summary>
        /// Clears the current list of command line parameters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearParameters();
		
		/// <summary>
        /// Appends a command line parameter to the command line
        /// parameter list.
        ///
        /// @param param the parameter to add.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AppendParameter([MarshalAs(UnmanagedType.LPStruct)] nsAString param);
		
		/// <summary>
        /// Retrieves a specific command line parameter.
        ///
        /// @param param the index of the parameter to return.
        ///
        /// @return the parameter string.
        ///
        /// @throw NS_ERROR_INVALID_ARG if the index is out of range.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsAString GetParameter(System.UInt32  parameterIndex);
		
		/// <summary>
        /// Checks to see if a parameter exists in the command line
        /// parameter list.
        ///
        /// @param param the parameter to search for.
        ///
        /// @return TRUE if the parameter exists in the current list.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ParameterExists([MarshalAs(UnmanagedType.LPStruct)] nsAString param);
	}
	
	/// <summary>
    /// nsIWebHandlerApp is a web-based handler, as speced by the WhatWG HTML5
    /// draft.  Currently, only GET-based handlers are supported.  At some point,
    /// we probably want to work with WhatWG to spec out and implement POST-based
    /// handlers as well.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("7521a093-c498-45ce-b462-df7ba0d882f6")]
	public interface nsIWebHandlerApp : nsIHandlerApp
	{
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Whether or not the given handler app is logically equivalent to the
        /// invokant (i.e. they represent the same app).
        ///
        /// Two apps are the same if they are both either local or web handlers
        /// and their executables/URI templates and command line parameters are
        /// the same.
        ///
        /// @param aHandlerApp the handler app to compare to the invokant
        ///
        /// @returns true if the two are logically equivalent, false otherwise
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool Equals([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aHandlerApp);
		
		/// <summary>
        /// Launches the application with the specified URI.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        ///
        /// Currently only relevant to web-handler apps.  If given, this
        /// represents the docshell to load the handler in and is passed
        /// through to nsIURILoader.openURI.  If this parameter is null or
        /// not present, the web handler app implementation will attempt to
        /// find/create a place to load the handler and do so.  As of this
        /// writing, it tries to load the web handler in a new window using
        /// nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
        /// have a more comprehensive strategy which could include handing
        /// off to the system default browser (bug 394479).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
		
		/// <summary>
        /// Template used to construct the URI to GET.  Template is expected to have
        /// a %s in it, and the escaped URI to be handled is inserted in place of
        /// that %s, as per the HTML5 spec.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetUriTemplateAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aUriTemplate);
		
		/// <summary>
        /// Template used to construct the URI to GET.  Template is expected to have
        /// a %s in it, and the escaped URI to be handled is inserted in place of
        /// that %s, as per the HTML5 spec.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetUriTemplateAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aUriTemplate);
	}
	
	/// <summary>
    /// nsIDBusHandlerApp represents local applications launched by DBus a message
    /// invoking a method taking a single string argument descibing a URI
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1ffc274b-4cbf-4bb5-a635-05ad2cbb6534")]
	public interface nsIDBusHandlerApp : nsIHandlerApp
	{
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Human readable name for the handler
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aName);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Detailed description for this handler. Suitable for
        /// a tooltip or short informative sentence.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetDetailedDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aDetailedDescription);
		
		/// <summary>
        /// Whether or not the given handler app is logically equivalent to the
        /// invokant (i.e. they represent the same app).
        ///
        /// Two apps are the same if they are both either local or web handlers
        /// and their executables/URI templates and command line parameters are
        /// the same.
        ///
        /// @param aHandlerApp the handler app to compare to the invokant
        ///
        /// @returns true if the two are logically equivalent, false otherwise
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool Equals([MarshalAs(UnmanagedType.Interface)] nsIHandlerApp  aHandlerApp);
		
		/// <summary>
        /// Launches the application with the specified URI.
        ///
        /// @param aURI
        /// The URI to launch this application with
        ///
        /// @param aWindowContext
        ///
        /// Currently only relevant to web-handler apps.  If given, this
        /// represents the docshell to load the handler in and is passed
        /// through to nsIURILoader.openURI.  If this parameter is null or
        /// not present, the web handler app implementation will attempt to
        /// find/create a place to load the handler and do so.  As of this
        /// writing, it tries to load the web handler in a new window using
        /// nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
        /// have a more comprehensive strategy which could include handing
        /// off to the system default browser (bug 394479).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void LaunchWithURI([MarshalAs(UnmanagedType.Interface)] nsIURI  aURI, [MarshalAs(UnmanagedType.Interface)] nsIInterfaceRequestor  aWindowContext);
		
		/// <summary>
        /// Service defines the dbus service that should handle this protocol.
        /// If its not set,  NS_ERROR_FAILURE will be returned by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetServiceAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aService);
		
		/// <summary>
        /// Service defines the dbus service that should handle this protocol.
        /// If its not set,  NS_ERROR_FAILURE will be returned by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetServiceAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aService);
		
		/// <summary>
        /// Objpath defines the object path of the dbus service that should handle
        /// this protocol. If its not set,  NS_ERROR_FAILURE will be returned
        /// by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetObjectPathAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aObjectPath);
		
		/// <summary>
        /// Objpath defines the object path of the dbus service that should handle
        /// this protocol. If its not set,  NS_ERROR_FAILURE will be returned
        /// by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetObjectPathAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aObjectPath);
		
		/// <summary>
        /// DBusInterface defines the interface of the dbus service that should
        /// handle this protocol. If its not set,  NS_ERROR_FAILURE will be
        /// returned by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDBusInterfaceAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aDBusInterface);
		
		/// <summary>
        /// DBusInterface defines the interface of the dbus service that should
        /// handle this protocol. If its not set,  NS_ERROR_FAILURE will be
        /// returned by LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDBusInterfaceAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aDBusInterface);
		
		/// <summary>
        /// Method defines the dbus method that should be invoked to handle this
        /// protocol. If its not set,  NS_ERROR_FAILURE will be returned by
        /// LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetMethodAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aMethod);
		
		/// <summary>
        /// Method defines the dbus method that should be invoked to handle this
        /// protocol. If its not set,  NS_ERROR_FAILURE will be returned by
        /// LaunchWithURI
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMethodAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String  aMethod);
	}
}
